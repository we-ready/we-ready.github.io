{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210203101_nestjs",
    "result": {"pageContext":{"frontmatter":{"id":"20210203101_nestjs","title":"nestjs 101","subtitle":"如何利用 nodejs 的优势完成全栈开发，强烈推荐基于 nodejs 的后端开发框架：nestjs","subject":"fullstack","authors":"Chris Wei","keywords":"nestjs;AOP;Decorator;面向切面;装饰器","tags":"nestjs;AOP;Aspect Oriented Programming;","category":"概念理解","cover":"https://d33wubrfki0l68.cloudfront.net/e937e774cbbe23635999615ad5d7732decad182a/26072/logo-small.ede75a6b.svg","videos":null,"created_when":"2021-02-03","updated_when":"2022-03-13","level":100},"excerpt":"# nestjs 101\n\n# 参考资料\n\n*   [让我们用Nestjs来重写一个CNode]()\n","html":"<h1>nestjs 101</h1>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/f0a4944e8fb9\">让我们用Nestjs来重写一个CNode</a></li>\n</ul>\n<h2>概念</h2>\n<h4>核心组件</h4>\n<blockquote>\n<p>NestJs 主要有 8 个组件（Controller 控制器、Component 组件、Module 模块、Middlewares 中间件、Exception Filters 异常过滤器、Pipes 管道、Guards 守卫、Interceptors 拦截器）\nComponent 是 NestJs Ver 4.5 的称呼，5.0 之后成为 Provider</p>\n</blockquote>\n<h4>不同角色在请求过程中的执行顺序</h4>\n<blockquote>\n<p>客户端请求 ---> 中间件 ---> 守卫 ---> 拦截器之前 ---> 管道 ---> 控制器处理并响应 ---> 拦截器之后 ---> 过滤器</p>\n</blockquote>\n<h4>不同角色的特点</h4>\n<ul>\n<li>\n<p>功能</p>\n<ul>\n<li>中间件    ：访问 请求（req） 和 响应（res） 对象，并调用下一个 中间件（next）</li>\n<li>过滤器    ：处理所有抛出的异常</li>\n<li>管道      ：对请求参数做变形（纯函数）</li>\n<li>守卫      ：做权限认证</li>\n<li>拦截器    ：特殊功能，类似于AOP面向切面编程，</li>\n</ul>\n</li>\n<li>\n<p>实现方式</p>\n<ul>\n<li>中间件    ：由 @Injectable() 装饰的类 | 函数</li>\n<li>过滤器    ：</li>\n<li>管道      ：用@Injectable()装饰器注释的类</li>\n<li>守卫      ：用@Injectable()装饰器注释的类</li>\n<li>拦截器    ：用@Injectable()装饰器注释的类</li>\n</ul>\n</li>\n<li>\n<p>实现为类时，所需实现的接口</p>\n<ul>\n<li>中间件    ：NestMiddleware</li>\n<li>过滤器    ：ExceptionFilter</li>\n<li>管道      ：PipeTransform</li>\n<li>守卫      ：CanActivate</li>\n<li>拦截器    ：NestInterceptor</li>\n</ul>\n</li>\n<li>\n<p>使用方式</p>\n<ul>\n<li>中间件    ：全局注册（app.use）               | 模块注册（config(consumer) { consumer.apply().with().exclude().forRoutes()）</li>\n<li>过滤器    ：全局注册（app.useGlobalFilters）  | 装饰器（@UseFilters）装饰控制器   | 装饰器（@UseFilters）装饰路由</li>\n<li>管道      ：全局注册（app.useGlobalPipes）    | 作用于当前控制器（@UsePipes)      | 作用于当前路由（@UsePipes)        | 作用于当前的 Body（@Body）</li>\n<li>守卫      ：全局注册（app.useGlobalGuards）   | 作用于当前控制器（@UseGuards)</li>\n<li>拦截器    ：全局注册（app.useGlobalInterceptors）   | 作用于当前控制器（@UseInterceptors)  | 作用于当前路由（@UseInterceptors)</li>\n</ul>\n</li>\n</ul>\n<h4>不同角色所需实现的接口</h4>\n<h2>框架中的面向切面编程（AOP）</h2>\n<h3>实例 1：后端服务记录请求响应的时间差（性能）</h3>\n<h4>创建一个 <code>Interceptor</code></h4>\n<pre><code>@Injectable()\nexport class BenchMarkInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable&#x3C;any> {\n    const req = context.switchToHttp().getRequest();\n    const method = req.method;\n    const url = req.url;\n    const mark = moment();\n\n    Logger.log(`>>>>>> ${method} ${url} ${mark.format('YYYY-MM-DD HH:mm:ss')}ms`, context.getClass().name);\n    return next.handle().pipe(\n      tap(() => Logger.log(`&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; ${method} ${url} ${moment().diff(mark)}ms`, context.getClass().name))\n    );\n  }\n}\n</code></pre>\n<h4>全局范围启用这个 <code>Interceptor</code></h4>\n<pre><code>app.useGlobalInterceptors(new BenchMarkInterceptor());\n</code></pre>\n<blockquote>\n<p>启用之后，每个请求响应，都会留下 <code>BenchMark</code> 的痕迹</p>\n</blockquote>\n<h3>实例 2：后端服务记录请求响应的操作员</h3>\n<h4>创建带参数的看守器（<code>Guard</code>）</h4>\n<pre><code>@Injectable()\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private authValue: number = 0, \n    private roleList: Array&#x3C;string> = null, \n    private appList: Array&#x3C;string> = null\n  ) { }\n\n  async canActivate(context: ExecutionContext): Promise&#x3C;boolean> {\n    const request = context.switchToHttp().getRequest();\n\n    if (!!this.appList &#x26;&#x26; this.appList.length > 0) {\n      if (!request.headers['application']) return false;\n      if (this.appList.indexOf(request.headers['application']) &#x3C; 0) return false;\n    }\n\n    if (!request.headers['authorization']) return false;\n    request['currentUser'] = await this.validateToken(request.headers['authorization']);\n    \n    if (!!this.roleList &#x26;&#x26; this.roleList.length > 0) {\n      if (!request['currentUser']['roleName']) return false;\n      if (this.roleList.indexOf(request['currentUser']['roleName']) &#x3C; 0) return false;\n    }\n\n    if ( this.authValue > 0 ) {\n      if ( this.authValue !== (this.authValue &#x26; request['currentUser']['authValue']) ) return false;\n    }\n\n    return true;\n  }\n\n  ...\n\n</code></pre>\n<blockquote>\n<p>看守器负责检查每个请求的凭证，决定请求是否可以继续。如果可以继续，看守器还负责提取用户相关信息，并将信息附加在请求上下文中。</p>\n</blockquote>\n<h4>创建装饰器</h4>\n<pre><code>export const CurrentUser = createParamDecorator((param: string , ctx: ExecutionContext) => { \n  const request = ctx.switchToHttp().getRequest();\n  return (\n    !request.currentUser ? null :\n    !param ? request.currentUser : request.currentUser[param]\n  )\n});\n</code></pre>\n<blockquote>\n<p>装饰器负责从请求上下文，提取所需的用户信息。</p>\n</blockquote>\n<h4>为需要做权限控制的控制器添加守护器</h4>\n<pre><code>@UseGuards(\n  new AuthGuard()\n)\nexport class ContentController extends BaseController('contents') {\n  constructor(public service: ContentService) {\n    super(service);\n  }\n}\n</code></pre>\n<blockquote>\n<p>可以带参数做精细控制，也可以不带参数做常规控制</p>\n</blockquote>\n<blockquote>\n<p>因为控制器基类统一做了操作，所以，具体的每个控制器，就不必做了</p>\n</blockquote>\n<h4>基类控制器通过装饰器获取用户信息</h4>\n<pre><code>export function BaseController(controllerName: string): any {\n  abstract class AbstractBaseController {\n    constructor(public service: BaseService) { }\n\n    @Post()\n    @ApiOperation({ summary: `Create many ${controllerName}` })\n    async create(@Body() payload: any, @CurrentUser('credentialId') currentCredentialId: string) {\n      // Logger.log('BaseController::created_by: ', currentCredentialId);\n      // Logger.log('BaseController::create.body: ', payload);\n</code></pre>\n<blockquote>\n<p>上面代码，通过装饰器 <code>@CurrentUser</code> 提取了 <code>credentialId</code>。</p>\n</blockquote>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}