{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210203101_nestjs",
    "result": {"pageContext":{"frontmatter":{"id":"20210203101_nestjs","title":"Nestjs 框架概要入门","subtitle":"NestJS 基于 NodeJS 的后端开发框架","subject":"backend","authors":"Chris Wei","keywords":"nestjs;AOP;Decorator;面向切面;装饰器","tags":"nestjs;AOP;Aspect Oriented Programming;","category":"概念理解","cover":"https://d33wubrfki0l68.cloudfront.net/e937e774cbbe23635999615ad5d7732decad182a/26072/logo-small.ede75a6b.svg","videos":null,"created_when":"2021-02-03T00:00:00.000Z","updated_when":"2022-03-20T00:00:00.000Z","level":100},"excerpt":"# Nestjs 框架概要入门\n\n# 前言\n\n# 常见问题\n\n*   “做后端开发，用什么框架好”\n\n*   “学习后端开发，是不是要从 Expre…\n","html":"<h1>Nestjs 框架概要入门</h1>\n<h2>前言</h2>\n<h4>常见问题</h4>\n<ul>\n<li>“做后端开发，用什么框架好”</li>\n<li>“学习后端开发，是不是要从 Express 开始”</li>\n</ul>\n<blockquote>\n<p>我的答案是：<code>NestJS</code>，毫无疑问，毫无悬念</p>\n</blockquote>\n<h4>历史回顾</h4>\n<ul>\n<li><code>NodeJS</code> 的出世，把 <code>JS</code> 从台前引入幕后，让 <code>JS</code> 语言可以在 服务器 后端开发上大展拳脚</li>\n<li>最早配合 <code>NodeJS</code> 在后端开发闯天下的是 <code>Express</code>。如其名，开发起来快，配合 <code>NodeJS</code> 的异步非阻塞 特点，一下子打开局面</li>\n<li><code>NodeJS</code> 出世时， <code>JS</code> 的语法功能还比较弱，基于 <code>NodeJS</code> 的后端开发，更多的还只是小项目试水</li>\n<li>随着时间发展，各种新的 <code>ES</code> 升级语法规范出台，<code>TS</code> 语言越来越流行</li>\n<li><code>Express</code> 越来越无法满足 开发复杂业务逻辑的后端服务需求</li>\n<li>其他语言的框架，比如 <code>Java Sprint</code>，已经积累了很多成果，很多经验，很多理念</li>\n<li>在上述大背景下，<code>NestJS</code> 出现</li>\n<li>2019年开始使用 <code>NestJS</code>，当时是 <code>4.0</code>，今天 <code>NestJS</code> 是 <code>8.0</code></li>\n<li>说明了市场的任何度、接受度，其本身的生命力、前期设计的合理性、适应性、可信度</li>\n</ul>\n<h2>什么是 <code>NestJS</code></h2>\n<p><code>NestJS</code> 是基于 <code>NodeJS</code> 的后端服务开发框架</p>\n<ul>\n<li>对比 基于 <code>NodeJS</code> 的前端开发框架 <code>ReadJS</code> 的小而美，<code>NestJS</code> 框架是大而全</li>\n<li><code>NestJS</code> 是 <code>NestJS</code>，不是 <code>NextJS</code>，后者是一个基于 <code>ReactJS</code> 开发前端网站、前端应用的解决方案，重点实现后端服务渲染（<code>SSR</code>）</li>\n</ul>\n<h2>特点与优势</h2>\n<ul>\n<li>大而全</li>\n<li>单例模式，依赖注入</li>\n<li>统一的异常处理</li>\n<li>面向切面</li>\n<li>支持 <code>TS</code> （使用了很多高级语法，使得编码变得很简单、清晰）</li>\n</ul>\n<h2>概念</h2>\n<blockquote>\n<p>因为是 大而全，所以无法在一个视频里面面俱到，把所有概念全部解释清楚。本视频只会涉及最基本的、开发所必要的相关内容，不会涉及非常见内容、辅助功能，或者是基础功能的高级用法。在后续视频，会涉及更多内容。</p>\n</blockquote>\n<h4>核心组件（NestJS 的内含）</h4>\n<blockquote>\n<p>不同于 <code>Express</code> 的中间件包打天下，<code>NestJs</code> 主要有 8 个组件</p>\n</blockquote>\n<ul>\n<li>\n<p>Controller 控制器</p>\n<blockquote>\n<p>控制器负责处理传入的请求和向客户端返回响应。</p>\n</blockquote>\n</li>\n<li>\n<p>Provider 提供者</p>\n<blockquote>\n<p>许多基本的 <code>Nest</code> 类可能被视为 <code>Provider</code>。可以通过 <code>constructor</code> 注入依赖关系。\n最常见的就是 <code>Service</code></p>\n</blockquote>\n</li>\n<li>\n<p>Module 模块</p>\n<blockquote>\n<p>模块是具有 <code>@Module()</code> 装饰器的类。<code>Nest</code> 用它来组织应用程序的运行时结构（源文件的目录结构只决定静态代码结构）。</p>\n</blockquote>\n</li>\n<li>\n<p>Middlewares 中间件</p>\n</li>\n</ul>\n<blockquote>\n<p>中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 <code>next()</code> 中间件函数。</p>\n</blockquote>\n<ul>\n<li>\n<p>Exception Filters 异常过滤器</p>\n<blockquote>\n<p>内置的异常层负责处理整个应用程序中的所有抛出的异常。</p>\n</blockquote>\n</li>\n<li>\n<p>Pipes 管道</p>\n<blockquote>\n<p>管道可以把请求参数根据特定条件验证类型、对象结构或映射数据。</p>\n</blockquote>\n</li>\n<li>\n<p>Guards 守卫</p>\n<blockquote>\n<p>守卫可以做权限认证，如果你没有权限可以拒绝你访问这个路由，默认返回403错误。</p>\n</blockquote>\n</li>\n<li>\n<p>Interceptors 拦截器</p>\n<blockquote>\n<p>一个拦截器，会分成两部分，在请求处理前和请求处理后，合作完成一个功能</p>\n</blockquote>\n</li>\n<li>\n<p>自定义装饰器</p>\n</li>\n</ul>\n<h4>不同角色在请求过程中的执行顺序和所处位置</h4>\n<p>最初来自前端的请求 ---> 中间件 ---> 守卫 ---> 拦截器（前置） ---> 管道 ---> 控制器处理并响应 ---> 拦截器（后置）---> 过滤器 ---> 最终返回前端的响应\n↑ ↓\n↑ ↓\n↑ ↓\nProvider</p>\n<h4>NestJS 的外延</h4>\n<ul>\n<li>数据库 ORM</li>\n<li>缓存</li>\n<li>日志</li>\n<li>事件</li>\n<li>文件上传</li>\n<li>定时任务</li>\n<li>Session、Cookie</li>\n<li>安全认证、权限保护、跨域访问</li>\n<li>WebSocket</li>\n<li>GraphQL</li>\n<li>微服务</li>\n</ul>\n<h4>简单理解面向切面编程（AOP）</h4>\n<h4>不同角色的特点</h4>\n<ul>\n<li>\n<p>功能</p>\n<ul>\n<li>中间件    ：访问 请求（req） 和 响应（res） 对象，并调用下一个 中间件（next）</li>\n<li>过滤器    ：处理所有抛出的异常</li>\n<li>管道      ：对请求参数做变形（纯函数）</li>\n<li>守卫      ：做权限认证</li>\n<li>拦截器    ：特殊功能，类似于AOP面向切面编程，</li>\n</ul>\n</li>\n<li>\n<p>实现方式</p>\n<ul>\n<li>中间件    ：由 @Injectable() 装饰的类 | 函数</li>\n<li>过滤器    ：</li>\n<li>管道      ：用@Injectable()装饰器注释的类</li>\n<li>守卫      ：用@Injectable()装饰器注释的类</li>\n<li>拦截器    ：用@Injectable()装饰器注释的类</li>\n</ul>\n</li>\n<li>\n<p>实现为类时，所需实现的接口</p>\n<ul>\n<li>中间件    ：NestMiddleware</li>\n<li>过滤器    ：ExceptionFilter</li>\n<li>管道      ：PipeTransform</li>\n<li>守卫      ：CanActivate</li>\n<li>拦截器    ：NestInterceptor</li>\n</ul>\n</li>\n<li>\n<p>使用方式</p>\n<ul>\n<li>中间件    ：全局注册（app.use）               | 模块注册（config(consumer) { consumer.apply().with().exclude().forRoutes()）</li>\n<li>过滤器    ：全局注册（app.useGlobalFilters）  | 装饰器（@UseFilters）装饰控制器   | 装饰器（@UseFilters）装饰路由</li>\n<li>管道      ：全局注册（app.useGlobalPipes）    | 作用于当前控制器（@UsePipes)      | 作用于当前路由（@UsePipes)        | 作用于当前的 Body（@Body）</li>\n<li>守卫      ：全局注册（app.useGlobalGuards）   | 作用于当前控制器（@UseGuards)</li>\n<li>拦截器    ：全局注册（app.useGlobalInterceptors）   | 作用于当前控制器（@UseInterceptors)  | 作用于当前路由（@UseInterceptors)</li>\n</ul>\n</li>\n</ul>\n<h2>实战</h2>\n<ul>\n<li><a href=\"https://nestjs.com/\">官网</a></li>\n</ul>\n<h4>安装</h4>\n<pre><code>$ npm i -g @nestjs/cli\n$ nest new project-name\n</code></pre>\n<h4>开箱</h4>\n<ul>\n<li><code>controller</code></li>\n<li><code>service</code></li>\n<li><code>module</code></li>\n</ul>\n<h4>New Cat</h4>\n<ul>\n<li>controller: router</li>\n<li>service</li>\n<li>module</li>\n<li>folder</li>\n</ul>\n<h4>交叉调用</h4>\n<ul>\n<li>exports</li>\n<li>imports</li>\n</ul>\n<h4>全局模块</h4>\n<ul>\n<li>new module</li>\n<li>@Global()</li>\n<li>import from App</li>\n</ul>\n<h4>Logger</h4>\n<ul>\n<li>类函数</li>\n</ul>\n<pre><code>import { Logger, Controller, Get, Param } from '@nestjs/common';\n\n... ...\n\nLogger.log(\"Logger.log\")\n</code></pre>\n<ul>\n<li>实例函数</li>\n</ul>\n<pre><code>  ... ...\n  private readonly logger\n  constructor(private readonly coreService: CoreService) {\n    this.logger = new Logger(\"CATSERVICE\");\n  }\n\n  this.logger.log(\"this.logger.log\")\n</code></pre>\n<h4>Param （装饰器）</h4>\n<pre><code>@Get('demo/:key')\ncheckParam(@Param('key') key: string)\n</code></pre>\n<h4>Query （装饰器）</h4>\n<pre><code>@Get('demo')\ngetQ(@Query() q: any)\n</code></pre>\n<blockquote>\n<p>@Query('a')  @Query('b')</p>\n</blockquote>\n<h4>内置装饰器</h4>\n<ul>\n<li>@Request() @Response() @Next()</li>\n<li>@Session()</li>\n<li>@Param(param?: string)</li>\n<li>@Query(param?: string)</li>\n<li>@Headers(param?: string)</li>\n<li>@Body(param?: string)</li>\n<li>@Get() @Put() @Post() @Delete() @Patch() @Options()</li>\n</ul>\n<h4>拦截器 <code>Interceptor</code></h4>\n<ul>\n<li>创建 <code>LogInter.ts</code></li>\n</ul>\n<pre><code>import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LoggingInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable&#x3C;any> {\n    console.log('Before...');\n\n    const now = Date.now();\n    return next\n      .handle()\n      .pipe(\n        tap(() => console.log(`After... ${Date.now() - now}ms`)),\n      );\n  }\n}\n</code></pre>\n<ul>\n<li>控制器绑定</li>\n</ul>\n<pre><code>@UseInterceptors(LoggingInterceptor)\nexport class CatsController {}\n</code></pre>\n<ul>\n<li>全局范围启用</li>\n</ul>\n<pre><code>app.useGlobalInterceptors(new BenchMarkInterceptor());\n</code></pre>\n<h4>带参数的看守器（<code>Guard</code>）</h4>\n<ul>\n<li>创建 <code>AuthGuard</code></li>\n</ul>\n<pre><code>@Injectable()\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private minLevel: number = 0, \n  ) { }\n\n  async canActivate(context: ExecutionContext): Promise&#x3C;boolean> {\n    const request = context.switchToHttp().getRequest();\n    console.log(request.query)\n\n    const reqLevel = parseInt(request.query?.level || '0')\n\n    return (!!reLevel &#x26;&#x26; (reqLevel > minLevel));\n  }\n</code></pre>\n<ul>\n<li>绑定</li>\n</ul>\n<pre><code>@UseGuards(\n  new AuthGuard(10)\n)\n</code></pre>\n<h4>自定义装饰器</h4>\n<ul>\n<li>看守器改造</li>\n</ul>\n<pre><code>  request.userInfo = { level: reqLevel, name: 'Chris' };\n</code></pre>\n<ul>\n<li>创建 <code>UserInfo.ts</code></li>\n</ul>\n<pre><code>export const UserInfo = createParamDecorator((param: string , ctx: ExecutionContext) => { \n  const request = ctx.switchToHttp().getRequest();\n  return ( request.userInfo?.[param] || request.userInfo || null )\n});\n</code></pre>\n<ul>\n<li>使用</li>\n</ul>\n<pre><code>    @Get()\n    demo(@CurrentUser('name') userName: string) {\n      ... ...\n    }\n</code></pre>\n<h2>视频链接</h2>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1rP4y1u7BJ/\">安装及核心代码入门</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Bu411q77j/\">基本概念补充说明</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1w44y1K7kR/\">面向切面编程演示</a></li>\n</ul>\n<h2>参考资料</h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/f0a4944e8fb9\">让我们用Nestjs来重写一个CNode</a></li>\n</ul>"}},
    "staticQueryHashes": ["2877226700","3159585216","3659731985","3670619862"]}