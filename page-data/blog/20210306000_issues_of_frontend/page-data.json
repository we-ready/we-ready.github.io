{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210306000_issues_of_frontend",
    "result": {"pageContext":{"frontmatter":{"id":"20210306000_issues_of_frontend","title":"前端开发中的疑难杂症","subtitle":"前端开发中的掉坑和出坑记录","subject":"Issues","authors":"Chris Wei","keywords":"bug;issue","tags":"form;react-hook-form","category":"疑难杂症","cover":"https://media.inkscape.org/media/resources/file/Ladybug-icon.png","created_when":"2021-03-06","updated_when":"2021-03-06","level":200},"excerpt":"# 前端开发中的疑难杂症\n\n# 表单内任意的 `button` 点击都会触发 `submit`\n","html":"<h1>前端开发中的疑难杂症</h1>\n<h2>表单内任意的 <code>button</code> 点击都会触发 <code>submit</code></h2>\n<blockquote>\n<p>在自定义表单组件的时候，任何情况下，都需要避免使用 <code>button</code></p>\n</blockquote>\n<h2><code>react-hook-form</code> 向自己二次封装的表单传入 onSubmit 的时候，需要二次传递，而不能直接作为 <code>handleSubmit</code> 的参数</h2>\n<blockquote>\n<p>正确的方式</p>\n</blockquote>\n<pre><code>export default function LoginForm ({toLogin}) {\n\n  ...\n\n  const onSubmit = (values) => {\n    if (!!toLogin) toLogin(values)\n  }\n  return (\n    &#x3C;FormContainer>\n      &#x3C;form onSubmit={handleSubmit(onSubmit)}>\n  \n  ...\n\n</code></pre>\n<blockquote>\n<p>错误的方式</p>\n</blockquote>\n<pre><code>export default function LoginForm ({toLogin}) {\n\n  ...\n\n  return (\n    &#x3C;FormContainer>\n      &#x3C;form onSubmit={handleSubmit(toLogin)}>\n  \n  ...\n</code></pre>\n<h2><code>react-hook-form</code> 中使用自定义的 <code>Input</code>，每次输入，第一次输入引发的渲染，会终止</h2>\n<h4>自制组件</h4>\n<pre><code>export const MoneyInputField: React.FC&#x3C;InputFieldProps>  = ({register, variant, type, label, name, placeholder, hint, errors, ...restProps}) => {\n  const refSpan = useRef(null);\n  const [spanWidth, setSpanWidth] = useState(null)\n  const [input, setInput] = useState&#x3C;string>('');\n  \n  const onChange = (e) => { \n    setInput(e.target.value) \n  }\n\n  useEffect(() => {\n    setSpanWidth(calculateWidth(refSpan?.current))\n  }, [refSpan?.current, input]);\n\n  return (\n    &#x3C;InputFieldContainer {...restProps} >\n      &#x3C;InputContainer className={variant} validInput={!!input} >\n        &#x3C;SpanHelper ref={refSpan}>{input || placeholder}&#x3C;/SpanHelper>\n        {!input ? null : &#x3C;InputPrefix>$&#x3C;/InputPrefix> }\n        &#x3C;InputStyled className={variant} type={ type || 'text' } name={name} placeholder= {placeholder} \n          ref={register}\n          value={input}\n          width={spanWidth || 'auto'}\n          onChange={onChange}\n        />\n      &#x3C;/InputContainer>\n    &#x3C;/InputFieldContainer>\n  )\n}\n\n</code></pre>\n<blockquote>\n<p>因为需要动态调整 <code>input</code> 的宽度，所以需要动态获取 <code>input</code> 的内容变化，导致这个组件，既像一个受控组件，也像一个非受控组件。</p>\n</blockquote>\n<h4>表单</h4>\n<pre><code>export default function PaymentAmountPage ({location}) { \n  const schema = yup.object().shape(SCHEMA);\n  const { register, control, handleSubmit, errors, formState: { isDirty } } = useForm({\n    // defaultValues: { ...initValues },\n    mode: 'onBlur',\n    resolver: yupResolver(schema),\n  });\n  const [amountToPay, setAmountToPay] = useState&#x3C;number>(0);\n\n  const history = useHistory();\n  const data = location?.state?.context;\n\n  const onPay = () => { ... }\n  // console.log(data);\n  return (\n    &#x3C;>\n      &#x3C;BillContainer>\n        &#x3C;form style={{width: '100%'}} noValidate onSubmit={handleSubmit(onPay)} >\n          &#x3C;MoneyInputField style={{padding: '0 24px'}}\n            register={register}\n            errors={errors}\n            name='amount'\n            placeholder='Enter Total Bill Amount Here'\n          />\n          { !data?.showExcluded ? null :\n            &#x3C;MoneyInputField style={{marginTop: '24px', padding: '0 24px'}} variant=\"red\"\n              register={register}\n              errors={errors}\n              name='excluded'\n              placeholder='Enter Excluded Amount Here'\n            />\n          }\n\n          &#x3C;SummaryBill onChange={setAmountToPay} control={control} {...data} />\n\n          &#x3C;div style={{marginTop: '32px', padding:'0 24px'}} >\n            &#x3C;SubmitButton disabled={!isDirty}>Pay Now&#x3C;/SubmitButton>\n          &#x3C;/div>\n        &#x3C;/form>\n      &#x3C;/BillContainer>\n\n</code></pre>\n<blockquote>\n<p>这个案例中，按照非受控组件来使用 <code>&#x3C;MoneyInputField></code>。</p>\n</blockquote>\n<blockquote>\n<p>同时又要实时根据非受控组件的取值来更新一些内容，因此，引入了 <code>&#x3C;SummaryBill></code>，去监听表单字段的变化。</p>\n</blockquote>\n<blockquote>\n<p>注意这里的 <code>&#x3C;SummaryBill onChange={setAmountToPay} ...</code>，会引发 <code>Bug</code>。</p>\n</blockquote>\n<h4>监听实时变化</h4>\n<pre><code>const SummaryBill:React.FC&#x3C;SummaryBillProps> = ({onChange, control, promotion}) => {\n  \n  ...\n\n  const values = useWatch&#x3C;any>({\n    control,\n    defaultValue: {}\n  });\n\n  ...\n\n  const amountToPay     = validBillAmount - discountAmount - voucherDeduction;\n\n  ...\n\n  useEffect(() => {\n    if (!!onChange) {\n      console.log('onChange amountToPay: ', amountToPay);\n      onChange(amountToPay);\n    }\n  }, [values])\n\n</code></pre>\n<h4>Bug 描述</h4>\n<p>当 <code>SummaryBill</code> 监听 <code>values</code>，并在 <code>values</code> 变化之后，把计算结果，通过 <code>onChange</code> 回调，回传给 <code>Form</code> 组件，而 <code>Form</code> 组件又调用 <code>setAmountToPay</code> 的时候，<code>Bug</code> 出现了。\nBug 的具体表现是：在 <code>input</code> 中的输入（键盘），能被代码识别，但无法完成渲染。比如键盘输入：<code>11</code>，第一个 <code>1</code>，无法渲染到界面。\n如果，仅仅停止调用 <code>setAmountToPay</code> ， 一切又正常了。</p>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}