{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210125005_pg_crosstab",
    "result": {"pageContext":{"frontmatter":{"id":"20210125005_pg_crosstab","title":"postgres 数据库的数据透视表","subtitle":"利用 pg 数据库的 crosstab 扩展功能，实现类似数据透视表的数据分类查询统计","subject":"数据统计","authors":"Chris Wei","keywords":"crosstab;pivot;行列转置","tags":"postgresql","category":"经验技巧","cover":"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=241539469,1732296879&fm=26&gp=0.jpg","videos":null,"created_when":"2021-01-25","updated_when":"2021-01-25","level":300},"excerpt":"# postgres数据库的数据透视表\n\n# 背景 & 需求\n","html":"<h1>postgres数据库的数据透视表</h1>\n<h2>背景 &#x26; 需求</h2>\n<p>几乎所有系统的<code>数据表</code>，可能都会有一些<code>状态字段</code>，这些字段的取值是有限个<code>状态</code>。无论是运营的需求层面，还是程序运行的业务逻辑判断层面，往往需要对这些<code>数据表</code>中的记录，根据不同的状态进行汇总统计，获取不同状态下，所有记录的统计结果。</p>\n<p>例如，假设一个 <em>任务</em> <code>数据表</code>(<code>t_tasks</code>)：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">project_code</th>\n<th align=\"center\">state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1001</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1002</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1003</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">DONE</td>\n</tr>\n<tr>\n<td align=\"center\">1004</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">PENDING</td>\n</tr>\n<tr>\n<td align=\"center\">1005</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1006</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1007</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">DONE</td>\n</tr>\n<tr>\n<td align=\"center\">1008</td>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">PENDING</td>\n</tr>\n<tr>\n<td align=\"center\">1009</td>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">WORKING</td>\n</tr>\n</tbody>\n</table>\n<p>期望得到这样的统计结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">project_code</th>\n<th align=\"center\">pending</th>\n<th align=\"center\">working</th>\n<th align=\"center\">done</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\"></td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<h2>解决方案</h2>\n<pre><code>SELECT *\nFROM crosstab(\n  'SELECT project_code::text, state, count(id) FROM t_tasks GROUP BY grouping sets((project_code, state)) ORDER BY 1,2',\n  $$values('PENDING'::text),('WORKING'::text),('DONE'::text)$$\n)\nAS (project text, PENDING int, WORKING int, DONE int)\n</code></pre>\n<blockquote>\n<p><code>crosstab</code> 是 <code>postgres</code> 的扩展功能，使用之前，需要安装相关扩展</p>\n</blockquote>\n<h2>说明</h2>\n<ul>\n<li><code>$$</code> 相当于单引号（<code>crosstab</code> 的参数是一个 SQL 语句字符串，字符串是由单引号括起来的，因此，在单引号里面，不能再使用单引号，这时候，可以使用 <code>$$</code> 代替单引号）</li>\n<li><code>crosstab</code> 有两个<code>入参</code>：<code>数据集</code>，<code>状态集</code></li>\n<li><code>数据集</code>有三列：<code>行标识</code>, <code>状态</code>, <code>取值</code></li>\n<li><code>状态集</code>：所有状态的列表</li>\n</ul>\n<h4>中间结果</h4>\n<p><code>SELECT project_code::text, state, count(id) FROM t_tasks GROUP BY grouping sets((project_code, state)) ORDER BY 1,2</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">project_code</th>\n<th align=\"center\">state</th>\n<th align=\"center\">count</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">DONE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">PENDING</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">DONE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">PENDING</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody>\n</table>\n<h2>关键点</h2>\n<ul>\n<li>构造一个 SQL 语句，能够取得中间结果；这个 SQL 语句，就是 <code>crosstab</code> 的第一个参数：<code>数据集</code></li>\n<li>指明一个<code>状态集</code>，作为 <code>crosstab</code> 的第二个参数</li>\n</ul>\n<h2>补充</h2>\n<h3>状态集 的构造方式</h3>\n<h4>固定的<code>状态集</code></h4>\n<pre><code>$$values('PENDING'::text),('WORKING'::text),('DONE'::text)$$\n</code></pre>\n<h4>动态的<code>状态集</code>，动态构造</h4>\n<pre><code>const stateArray = ['PENDING', 'WORKING', 'DONE']\nconst cstr = ....\nconst sql = `\n  SELECT \n    distinct qa.serial_code AS id,\n    fb.form_serial_code, fb.form_title, form_index, fb.form_id, \n    fb.notice_template_id, fb.notice_template_code,\n    fb.notice_serial_code, fb.notice_title, fb.notice_id, \n    fb.employer_path, fb.employer_id, \n    fb.source_path, fb.source_id, \n    fb.created_by,\n    fb.created_when,\n    fb.updated_by,\n    fb.updated_when,\n    qa.* \n  FROM crosstab(\n    'SELECT serial_code, question_key, answer_value FROM dbt_biz_logs WHERE ${cstr} ORDER BY 1, 2',\n    'SELECT * FROM unnest(array[${stateArray}]) as exp'\n  )\n  AS qa(serial_code text, ${qtuple})\n  LEFT JOIN dbt_biz_logs fb ON fb.serial_code=qa.serial_code AND fb.category='FORM_FEEDBACK_QA'\n`\n</code></pre>\n<h4>来自数据库的枚举类型</h4>\n<pre><code>'SELECT e.enumlabel FROM pg_type t, pg_enum e WHERE t.oid=e.enumtypid AND t.typname=''dbe_workflow_task_result'' ORDER BY 1'\n</code></pre>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}