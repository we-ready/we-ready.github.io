{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210226000_nestjs_aop",
    "result": {"pageContext":{"frontmatter":{"id":"20210226000_nestjs_aop","title":"Nestjs 框架中的面向切面编程（AOP）","subtitle":"如何通过面向切面编程，帮助优化代码结构，提升开发效率和质量","subject":"面向切面编程","authors":"Chris Wei","keywords":"AOP;Aspect Oriented Programming;Decorator;面向切面;装饰器","tags":"nestjs;AOP;","category":"概念理解","cover":"https://media.inkscape.org/media/resources/file/final_screen_contest_v1lRxcs.svg","created_when":"2021-02-26","updated_when":"2021-02-26","level":300},"excerpt":"# Nestjs 框架中的面向切面编程（A…\n","html":"<h1>Nestjs 框架中的面向切面编程（AOP）</h1>\n<h2>实例 1：后端服务记录请求响应的时间差（性能）</h2>\n<h4>创建一个 <code>Interceptor</code></h4>\n<pre><code>@Injectable()\nexport class BenchMarkInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable&#x3C;any> {\n    const req = context.switchToHttp().getRequest();\n    const method = req.method;\n    const url = req.url;\n    const mark = moment();\n\n    Logger.log(`>>>>>> ${method} ${url} ${mark.format('YYYY-MM-DD HH:mm:ss')}ms`, context.getClass().name);\n    return next.handle().pipe(\n      tap(() => Logger.log(`&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; ${method} ${url} ${moment().diff(mark)}ms`, context.getClass().name))\n    );\n  }\n}\n</code></pre>\n<h4>全局范围启用这个 <code>Interceptor</code></h4>\n<pre><code>app.useGlobalInterceptors(new BenchMarkInterceptor());\n</code></pre>\n<blockquote>\n<p>启用之后，每个请求响应，都会留下 <code>BenchMark</code> 的痕迹</p>\n</blockquote>\n<h2>实例 2：后端服务记录请求响应的操作员</h2>\n<h4>创建带参数的看守器（<code>Guard</code>）</h4>\n<pre><code>@Injectable()\nexport class AuthGuard implements CanActivate {\n\n  constructor(\n    private authValue: number = 0, \n    private roleList: Array&#x3C;string> = null, \n    private appList: Array&#x3C;string> = null\n  ) { }\n\n  async canActivate(context: ExecutionContext): Promise&#x3C;boolean> {\n    const request = context.switchToHttp().getRequest();\n\n    if (!!this.appList &#x26;&#x26; this.appList.length > 0) {\n      if (!request.headers['application']) return false;\n      if (this.appList.indexOf(request.headers['application']) &#x3C; 0) return false;\n    }\n\n    if (!request.headers['authorization']) return false;\n    request['currentUser'] = await this.validateToken(request.headers['authorization']);\n    \n    if (!!this.roleList &#x26;&#x26; this.roleList.length > 0) {\n      if (!request['currentUser']['roleName']) return false;\n      if (this.roleList.indexOf(request['currentUser']['roleName']) &#x3C; 0) return false;\n    }\n\n    if ( this.authValue > 0 ) {\n      if ( this.authValue !== (this.authValue &#x26; request['currentUser']['authValue']) ) return false;\n    }\n\n    return true;\n  }\n\n  ...\n\n</code></pre>\n<blockquote>\n<p>看守器负责检查每个请求的凭证，决定请求是否可以继续。如果可以继续，看守器还负责提取用户相关信息，并将信息附加在请求上下文中。</p>\n</blockquote>\n<h4>创建装饰器</h4>\n<pre><code>export const CurrentUser = createParamDecorator((param: string , ctx: ExecutionContext) => { \n  const request = ctx.switchToHttp().getRequest();\n  return (\n    !request.currentUser ? null :\n    !param ? request.currentUser : request.currentUser[param]\n  )\n});\n</code></pre>\n<blockquote>\n<p>装饰器负责从请求上下文，提取所需的用户信息。</p>\n</blockquote>\n<h4>为需要做权限控制的控制器添加守护器</h4>\n<pre><code>@UseGuards(\n  new AuthGuard()\n)\nexport class ContentController extends BaseController('contents') {\n  constructor(public service: ContentService) {\n    super(service);\n  }\n}\n</code></pre>\n<blockquote>\n<p>可以带参数做精细控制，也可以不带参数做常规控制</p>\n</blockquote>\n<blockquote>\n<p>因为控制器基类统一做了操作，所以，具体的每个控制器，就不必做了</p>\n</blockquote>\n<h4>基类控制器通过装饰器获取用户信息</h4>\n<pre><code>export function BaseController(controllerName: string): any {\n  abstract class AbstractBaseController {\n    constructor(public service: BaseService) { }\n\n    @Post()\n    @ApiOperation({ summary: `Create many ${controllerName}` })\n    async create(@Body() payload: any, @CurrentUser('credentialId') currentCredentialId: string) {\n      // Logger.log('BaseController::created_by: ', currentCredentialId);\n      // Logger.log('BaseController::create.body: ', payload);\n</code></pre>\n<blockquote>\n<p>上面代码，通过装饰器 <code>@CurrentUser</code> 提取了 <code>credentialId</code>。</p>\n</blockquote>\n<h2>补充信息</h2>\n<h4>数据表结构</h4>\n<pre><code>CREATE TABLE dbt_xxxxxxxx (\n    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    \n    created_by          UUID REFERENCES dbt_user_credentials (id) ON DELETE RESTRICT,\n    updated_by          UUID REFERENCES dbt_user_credentials (id) ON DELETE RESTRICT,\n\n    ...\n</code></pre>\n<blockquote>\n<p>每个表都有固定的常规字段</p>\n</blockquote>\n<h4>数据库触发器</h4>\n<pre><code>CREATE TRIGGER tg_dbt_contents_aft_update\nAFTER UPDATE ON dbt_contents\nFOR EACH ROW\nEXECUTE PROCEDURE fn_tg_t_ops_on_tracking();\n</code></pre>\n<blockquote>\n<p>数控触发器会保证每个需要的数据操作，都会留有日志记录（存储于独立的日志表）</p>\n</blockquote>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}