{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20220217000_promise",
    "result": {"pageContext":{"frontmatter":{"id":"20220217000_promise","title":"Promise 101","subtitle":"什么是 callback 陷阱，为什么会有 Promise，什么是 then/catch 链式调用，async/await 语法糖的巨大优势","subject":"js 借助 promise 和 async/await 从 callback 地狱逃出升天","authors":"Chris Wei","keywords":"callback;promise;then catch;async await","tags":"js;nodejs","category":"概念理解","cover":"https://media.inkscape.org/media/resources/file/Koi_carp_2.svg","videos":null,"created_when":"2022-02-17","updated_when":"2022-02-17","level":100},"excerpt":"# Promise 101\n\n# 最早的纯 `js` 非阻塞编程带来的 `callback` 陷阱（地狱）\n","html":"<h1>Promise 101</h1>\n<h2>最早的纯 <code>js</code> 非阻塞编程带来的 <code>callback</code> 陷阱（地狱）</h2>\n<ul>\n<li>函数</li>\n</ul>\n<blockquote>\n<p>这里我们模拟创建一个函数 <code>fnDemoCallback</code>，假设其不得不使用一个带有 <code>callback</code> 回调形式的底层函数：<code>setTimeout</code>，从而引入了 <code>js</code> 的 <code>callback</code> 原罪；</p>\n</blockquote>\n<pre><code>const fnDemoCallback = (param, fnCallback) => {\n  setTimeout(() => {\n    if (\n      (typeof param !== 'number') ||\n      (param &#x3C; 60)\n    ) {\n      fnCallback(new Error(`Paramter error! [${param}]`))\n    } \n    else {\n      fnCallback(`You input is ${param}`)\n    }\n  }, 300);\n}\n</code></pre>\n<ul>\n<li>函数的使用</li>\n</ul>\n<blockquote>\n<p>这里我们只用最最原始的 <code>js</code> <code>callback</code> 回调语法</p>\n</blockquote>\n<pre><code>function demoCallback() {\n  fnDemoCallback(80, (result80) => {\n    if (result80 instanceof Error) {\n      console.error(result80)\n      return\n    }\n\n    console.log(result80)\n    fnDemoCallback(70, (result70) => {\n      if (result70 instanceof Error) {\n        console.error(result70)\n        return\n      }\n\n      console.log(result70)\n      fnDemoCallback(60, (result60) => {\n        if (result60 instanceof Error) {\n          console.error(result60)\n          return\n        }\n\n        console.log(result60)\n        fnDemoCallback(50, (result50) => {\n          if (result50 instanceof Error) {\n            console.error(result50)\n            return\n          }\n\n          console.log(result60)\n        })\n      })\n    })\n  })\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，相应的结果</li>\n</ul>\n<pre><code>demoCallback()\n\n/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>\n<h2>同样的情况，如果引入 <code>Promise</code>，则可以回避 <code>callback</code> 陷阱（地狱）</h2>\n<ul>\n<li>函数</li>\n</ul>\n<pre><code>const fnDemoPromise = (param) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (\n      (typeof param !== 'number') ||\n      (param &#x3C; 60)\n    ) {\n      reject(new Error(`Paramter error! ${param}`))\n    } \n    else {\n      resolve(`You input is ${param}`)\n    }\n  }, 300);\n})\n</code></pre>\n<ul>\n<li>函数的使用</li>\n</ul>\n<blockquote>\n<p>这里我们使用 <code>ES</code> 的 <code>then/catch</code> 链式调用，代码整洁了很多</p>\n</blockquote>\n<pre><code>function demoPromiseThen() {\n  fnDemoPromise(80)\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(70)\n  })\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(60)\n  })\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(50)\n  })\n  .then((result) => {\n    console.log(result)\n  })\n  .catch((err) => {\n    console.error(err)\n  })\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，相应的结果</li>\n</ul>\n<pre><code>demoPromiseThen()\n\n/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>\n<h2>针对同样的 <code>fnDemoPromise</code> 函数，如果使用 <code>async/await</code> 语法糖</h2>\n<ul>\n<li>函数的使用，可以这样</li>\n</ul>\n<pre><code>async function demoPromiseAwait8765() {\n  try {\n    console.log(await fnDemoPromise(80))\n    console.log(await fnDemoPromise(70))\n    console.log(await fnDemoPromise(60))\n    console.log(await fnDemoPromise(50))\n  }\n  catch(err) {\n    console.error(err)\n  }\n}\n</code></pre>\n<ul>\n<li>也可以这样</li>\n</ul>\n<pre><code>async function demoPromiseAwaitLoop() {\n  try {\n    for (let p = 80; p > 0; p-=10) {\n      let result = await fnDemoPromise(p)\n      console.log(result)\n    }\n  }\n  catch(err) {\n    console.error(err)\n  }\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，无论是 <code>demoPromiseAwait8765</code>，还是 <code>demoPromiseAwaitLoop</code> 相应的结果一样</li>\n</ul>\n<pre><code>/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}