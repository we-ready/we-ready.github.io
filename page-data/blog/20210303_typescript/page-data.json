{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20210303_typescript",
    "result": {"pageContext":{"frontmatter":{"id":"20210303_typescript","title":"什么是 Typescript","subtitle":"ts和js/es是什么关系？使用ts有什么好处？如何构建一个支持 ts 语法的 nodejs 项目","subject":"typescript","authors":"Chris Wei","keywords":"javascript;typescript;js;es;ts","tags":"typescript","category":"概念理解","cover":"https://oscimg.oschina.net/oscnet/4d61b0d3264e651fde2e5a07d856381323d.jpg","videos":null,"created_when":"2021-03-03","updated_when":"2021-03-14","level":200},"excerpt":"# 什么是 Typescript\n\n# 关系梳理\n\n*   JS (Javascript)\n\n    *   上世纪互联网出现之后，为了增强互联网用…\n","html":"<h1>什么是 Typescript</h1>\n<h2>关系梳理</h2>\n<ul>\n<li>\n<p>JS (Javascript)</p>\n<ul>\n<li>上世纪互联网出现之后，为了增强互联网用户访问网页的用户体验，网景 (Netscapte) 公司开发了一种可以随网页加载，并在浏览器中运行的脚本语言，名为 LiveScript 。而后，改名为 Javascript</li>\n<li>微软公司为了和网景公司在浏览器领域竞争，在 IE 浏览器里加入了类似的脚本语言，起名叫做 JScript</li>\n</ul>\n</li>\n<li>\n<p>ECMA (European Computer Manufacture)：欧洲计算机制造商协会</p>\n</li>\n<li>\n<p>ES (ECMAScript)</p>\n<ul>\n<li>随着浏览器层出不穷，大家互相竞争又各自为政，搞得互联网开发兼容问题不断，加之 Javascript 在满足各种开发需求方面，确实有很多短板要补</li>\n<li>ECMA 基于 Javascript 和 JScript 开始制定标准，名叫：ES</li>\n<li>各方协商讨论（话语权之争）</li>\n<li>ES 也有不同的版本迭代：ES6 = ES2015，ES2016，ES2017..., ES7, ES8, ...</li>\n<li>所以，ES 是标准，从 JS 而来的标准</li>\n<li>JS 是 ES 标准的一种具体实现</li>\n</ul>\n</li>\n<li>\n<p>TS (Typescript)</p>\n<ul>\n<li>微软推出的编程语言（另起炉灶，独辟蹊径）</li>\n<li>JS 是脚本型语言，是动态语言（可以直接在运行时中执行，语句只有在<code>运行时</code>才知道是否能执行，是否报错，是否有异常：<code>anyObj.whatEver()</code>）</li>\n<li>TS 是静态语言，编译型语言（必须先由编译器编译成 JS 语言，编译时就会报错）</li>\n<li>TS 语法是 ES 的超级，包含很多还在讨论中的 ES 语法，TS 的很多创新，也可以向 ECMA 提交</li>\n<li>TS 是全新的一种语言，只是语法层面完全兼容现有 JS</li>\n</ul>\n</li>\n</ul>\n<h2>创建支持 TS 的项目</h2>\n<ul>\n<li>\n<p>创建目录</p>\n</li>\n<li>\n<p>项目初始化</p>\n</li>\n</ul>\n<pre><code>npm init -y\n</code></pre>\n<blockquote>\n<p><code>package.json</code></p>\n</blockquote>\n<ul>\n<li>安装</li>\n</ul>\n<pre><code>yarn add -D typescript ts-node @types/node tslint\n\n</code></pre>\n<p>或者使用 <code>npm</code></p>\n<pre><code>npm install --save-dev\n</code></pre>\n<blockquote>\n<p><code>devDependencies</code> in <code>package.json</code></p>\n</blockquote>\n<ul>\n<li>添加执行脚本 <code>package.json</code></li>\n</ul>\n<pre><code>  ... ...\n\n  \"scripts\": {\n    \"init:ts\": \"node_modules/.bin/tsc --init\",\n    \"init:lint\": \"node_modules/.bin/tslint --init\",\n    \"dev\": \"node_modules/.bin/ts-node ./main.ts\",\n    \"build\": \"node_modules/.bin/tsc\",\n    \"runjs\": \"node ./dist/main.js\",\n  ... ...\n</code></pre>\n<ul>\n<li>执行 <code>yarn init:ts</code></li>\n</ul>\n<blockquote>\n<p><code>tsconfig.json</code> 概要</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>include</code></td>\n<td><code>ts</code>文件所在的文件夹</td>\n</tr>\n<tr>\n<td><code>module</code></td>\n<td><code>ts</code>代码编译成什么模块系统</td>\n</tr>\n<tr>\n<td><code>target</code></td>\n<td><code>ts</code>编译成目标js的标准, \"ES3\", \"ES\", \"ES2017\"</td>\n</tr>\n<tr>\n<td><code>lib</code></td>\n<td>运行环境包含哪些 <code>api</code>, \"dom\", \"ES2017\"</td>\n</tr>\n<tr>\n<td><code>outDir</code></td>\n<td>编译后的输出目录</td>\n</tr>\n<tr>\n<td><code>strict</code></td>\n<td>严格模式</td>\n</tr>\n<tr>\n<td><code>removeComments</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>watch</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>修改</li>\n</ul>\n<pre><code>\"outDir\": \"./dist\", \n</code></pre>\n<h2>TS 源码</h2>\n<ul>\n<li>创建文件 <code>main.ts</code></li>\n</ul>\n<pre><code>console.log('hello world')\n</code></pre>\n<ul>\n<li>执行 <code>yarn build</code></li>\n<li>检查 <code>./dist/main.js</code></li>\n</ul>\n<blockquote>\n<p>TS 语法完全兼容 JS 语法</p>\n</blockquote>\n<h2>TS 源码（同样的 TS 语句，不同的 ES 版本）</h2>\n<ul>\n<li>更新文件 <code>main.ts</code></li>\n</ul>\n<pre><code>const delay: (n: number) => Promise&#x3C;any> = (n) => (\n    new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(null)\n        }, n * 1000)\n    })\n)\n\nasync function main() {\n    console.log('>>> main +++', new Date())\n    await delay(3)\n    console.log('&#x3C;&#x3C;&#x3C; main ---', new Date())\n}\n\nmain()\n</code></pre>\n<ul>\n<li>\n<p>执行 <code>yarn build</code></p>\n</li>\n<li>\n<p>检查 <code>main.js</code></p>\n</li>\n<li>\n<p>执行 <code>yarn runjs</code></p>\n</li>\n<li>\n<p>更新 <code>tsconfig.json</code></p>\n</li>\n</ul>\n<pre><code>\"target\": \"es3\",\n</code></pre>\n<pre><code>\"target\": \"es2017\",\n</code></pre>\n<blockquote>\n<p>同样的 TS 语句，可以针对不同目标标准，生成不同的 JS 语句</p>\n</blockquote>\n<h2>本地开发调试</h2>\n<pre><code>yarn dev\n</code></pre>\n<h2>语法</h2>\n<ul>\n<li>\n<p>类型说明</p>\n<ul>\n<li>隐式声明</li>\n</ul>\n<pre><code>let name = 'chris'\nname = 124\n</code></pre>\n<blockquote>\n<p>TS 语句和 JS 语句具有相同的语法，但有不同的标准；标准在一定程度上可配置</p>\n</blockquote>\n<ul>\n<li>显式声明</li>\n</ul>\n<pre><code>let name: string = 'chris'\nname = 124\n</code></pre>\n<pre><code>let name: any = 'chris'\nname = 124\n</code></pre>\n</li>\n<li>\n<p>类型</p>\n</li>\n</ul>\n<pre><code>type JobState = 'prepare' | 'doing' | 'done'\nconst s: JobState = 'done'\n</code></pre>\n<pre><code>type MetaData = [number?, string?, boolean?]\nconst s: MetaData = []\ns.push(123)\n</code></pre>\n<pre><code>type MetaData = number | null\nconst s: MetaData = 12\n</code></pre>\n<ul>\n<li>枚举</li>\n</ul>\n<pre><code>enum JobState {\n  new = 100,\n  pending,\n  working,\n  completed,\n  failed,\n  abort,\n}\n\nconst js: JobState = JobState.abort\n\nconsole.log(js)\n</code></pre>\n<pre><code>enum JobState {\n  new = 'N',\n  pending = \"P\",\n  working = \"W\",\n  completed = \"C\",\n  failed = \"F\",\n  abort = \"A\",\n}\n\nconst js: JobState = JobState.abort\n</code></pre>\n<ul>\n<li>接口</li>\n</ul>\n<pre><code>interface Room {\n  number: string;\n  size: number;\n  hasWindow?: boolean; \n  setTemp: (tmp: number) => void;\n}\n\nconst room1: Room = {\n}\n</code></pre>\n<ul>\n<li>函数接口</li>\n</ul>\n<pre><code>interface FnAdd {\n  (a: number, b: number): number;\n}\n\nconst fnAdd: FnAdd = (a, b) => (a + b)\n</code></pre>\n<ul>\n<li>函数参数及返回值</li>\n</ul>\n<pre><code>function fnAdd (a: number, b: number): number {\n  return a + b\n}\n</code></pre>\n<ul>\n<li>函数类型的变量</li>\n</ul>\n<pre><code>const fnAdd: (a: number, b: number) => number = (a, b) => a + b\n</code></pre>\n<h2>TS 的优势</h2>\n<ul>\n<li>进可攻：提供了很多语法规则，代码的可读性、可维护性、团队协同工程化程度更高（架构师可以制定基类、接口、类型，等，架构基础；团队可以分别开发，但能确保一致性）</li>\n<li>退可守：继承并发扬了 JS，领先于 ES，是 ES 的超级</li>\n<li>配合编辑器的功能，编码效率提升</li>\n<li>编译时可以规避大量低级错误（前提是开启并使用 TS 特性）</li>\n</ul>\n<h2>其他</h2>\n<ul>\n<li>初始化语法检查 <code>tslint.json</code></li>\n</ul>\n<blockquote>\n<p><code>tslint.json</code> 摘要</p>\n</blockquote>\n<pre><code>{\n  \"defaultSeverity\": \"error\",\n  \"extends\": [\n    \"tslint:recommended\"\n  ],\n  \"jsRules\": {},\n  \"rules\": {\n    \"no-console\": false\n  },\n  \"rulesDirectory\": []\n}\n</code></pre>"}},
    "staticQueryHashes": ["3159585216","3208650349","3659731985"]}