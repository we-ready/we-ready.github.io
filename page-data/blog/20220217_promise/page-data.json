{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/20220217_promise",
    "result": {"pageContext":{"frontmatter":{"id":"20220217_promise","title":"Promise 101","subtitle":"什么是 callback 陷阱，为什么会提出 Promise，Promise 和 then/catch 链式调用 还有 async/await 语法糖有什么关系","subject":"Promise","authors":"Chris Wei","keywords":"javascript;es;promise;then catch;async await","tags":"promise","category":"概念理解","cover":"https://media.inkscape.org/media/resources/file/Koi_carp_2.svg","videos":"https://qiniuargus.weready.online/blog/sharing/video/2022-03-11-promise-101.mp4","created_when":"2022-02-17T00:00:00.000Z","updated_when":"2022-03-11T00:00:00.000Z","level":100},"excerpt":"# Promise 101\n\n# 最早的纯 `js` 非阻塞编程带来的 `callback` 陷阱（地狱）\n","html":"<h1>Promise 101</h1>\n<h2>最早的纯 <code>js</code> 非阻塞编程带来的 <code>callback</code> 陷阱（地狱）</h2>\n<ul>\n<li>带有 <code>callback</code> 入参的函数模拟</li>\n</ul>\n<blockquote>\n<p>这里创建一个函数 <code>fnDemoCallback</code>，用于模拟第三方提供的以异步方式执行的函数。函数内部使用 <code>setTimeout</code>，模拟一个耗时的操作。调用函数需要提供 <code>callback</code> 回调函数的方式获取函数执行结果。</p>\n</blockquote>\n<pre><code>const fnDemoCallback = (param, fnCallback) => {\n  setTimeout(() => {\n    if (\n      (typeof param !== 'number') ||\n      (param &#x3C; 60)\n    ) {\n      fnCallback(new Error(`Paramter error! [${param}]`))\n    } \n    else {\n      fnCallback(`You input is ${param}`)\n    }\n  }, 300);\n}\n</code></pre>\n<ul>\n<li>函数的使用</li>\n</ul>\n<blockquote>\n<p>这里我们只用最最原始的 <code>js</code> <code>callback</code> 回调语法</p>\n</blockquote>\n<pre><code>function demoCallback() {\n  fnDemoCallback(80, (result80) => {\n    if (result80 instanceof Error) {\n      console.error(result80)\n      return\n    }\n\n    console.log(result80)\n    fnDemoCallback(70, (result70) => {\n      if (result70 instanceof Error) {\n        console.error(result70)\n        return\n      }\n\n      console.log(result70)\n      fnDemoCallback(60, (result60) => {\n        if (result60 instanceof Error) {\n          console.error(result60)\n          return\n        }\n\n        console.log(result60)\n        fnDemoCallback(50, (result50) => {\n          if (result50 instanceof Error) {\n            console.error(result50)\n            return\n          }\n\n          console.log(result60)\n        })\n      })\n    })\n  })\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，相应的结果</li>\n</ul>\n<pre><code>demoCallback()\n\n/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>\n<h2>同样的情况，如果引入 <code>Promise</code>，则可以回避 <code>callback</code> 陷阱（地狱）</h2>\n<ul>\n<li>函数</li>\n</ul>\n<pre><code>const fnDemoPromise = (param) => new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (\n      (typeof param !== 'number') ||\n      (param &#x3C; 60)\n    ) {\n      reject(new Error(`Paramter error! ${param}`))\n    } \n    else {\n      resolve(`You input is ${param}`)\n    }\n  }, 300);\n})\n</code></pre>\n<ul>\n<li>函数的使用</li>\n</ul>\n<blockquote>\n<p>这里我们使用 <code>ES</code> 的 <code>then/catch</code> 链式调用，代码整洁了很多</p>\n</blockquote>\n<pre><code>function demoPromiseThen() {\n  fnDemoPromise(80)\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(70)\n  })\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(60)\n  })\n  .then((result) => {\n    console.log(result)\n    return fnDemoPromise(50)\n  })\n  .then((result) => {\n    console.log(result)\n  })\n  .catch((err) => {\n    console.error(err)\n  })\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，相应的结果</li>\n</ul>\n<pre><code>demoPromiseThen()\n\n/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>\n<h2>针对同样的 <code>fnDemoPromise</code> 函数，如果使用 <code>async/await</code> 语法糖</h2>\n<ul>\n<li>函数的使用，可以这样</li>\n</ul>\n<pre><code>async function demoPromiseAwait8765() {\n  try {\n    console.log(await fnDemoPromise(80))\n    console.log(await fnDemoPromise(70))\n    console.log(await fnDemoPromise(60))\n    console.log(await fnDemoPromise(50))\n  }\n  catch(err) {\n    console.error(err)\n  }\n}\n</code></pre>\n<ul>\n<li>也可以这样</li>\n</ul>\n<pre><code>async function demoPromiseAwaitLoop() {\n  try {\n    for (let p = 80; p > 0; p-=10) {\n      let result = await fnDemoPromise(p)\n      console.log(result)\n    }\n  }\n  catch(err) {\n    console.error(err)\n  }\n}\n</code></pre>\n<ul>\n<li>上面的函数如果执行，无论是 <code>demoPromiseAwait8765</code>，还是 <code>demoPromiseAwaitLoop</code> 相应的结果一样</li>\n</ul>\n<pre><code>/**\nYou input is 80\nYou input is 70\nYou input is 60\nError: Paramter error! [50]\n */\n</code></pre>\n<h2>视频概要</h2>\n<ul>\n<li>常规函数，通过 <code>return</code> 返回结果</li>\n<li>通过回调函数返回结果</li>\n<li>依赖 <code>CPU</code> 执行的常规计算任务 vs. 依赖外部设备执行的 <code>IO</code> 任务</li>\n<li>同步阻塞式 vs. 异步非阻塞</li>\n<li>异常处理</li>\n<li>回调地狱</li>\n<li>通过 <code>Promise</code> 改造通过 回调函数 返回结果的异步非阻塞函数</li>\n<li><code>then/catch</code> 链条获取 <code>Promise</code> 的 <code>resolve</code> 或 <code>reject</code> 结果</li>\n<li><code>await/async</code> 把 异步非阻塞 在代码写法上改造为 同步阻塞</li>\n<li><code>await/async</code> 在实际执行上，仍然具有 异步非阻塞 的效率</li>\n<li><code>await/async</code> 实现循环式调用</li>\n<li>通过 <code>Promise.all</code> 实现多个异步函数并发抢占式运行</li>\n</ul>"}},
    "staticQueryHashes": ["2877226700","3159585216","3659731985","3670619862"]}