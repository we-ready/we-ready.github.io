{"data":{"allMarkdownRemark":{"nodes":[{"fields":{"filename":"README"},"frontmatter":{"id":null,"title":"关于 notebook","subtitle":null,"subject":"WeReady","author":"Chis Wei","keywords":"标题;主题;分类;标签;关键字;封面;作者;创建日期;更新日期","tags":"WeReady;Notebook","category":"声明公告","created_when":"2021-01-23","cover":null},"excerpt":"Title 标题 subject 主题，例如： 云计算、云原生、人工智能 (AI…","html":"<h1>Title</h1>\n<p>标题</p>\n<h1>subject</h1>\n<p>主题，例如：</p>\n<ul>\n<li>云计算、云原生、人工智能 (AI)、微服务、</li>\n<li>产品、设计、架构、开发、测试、运维、前端、后端、管理、</li>\n<li>Fullstack、Devops、</li>\n<li>版本管理、包管理、持续集成、持续发布、</li>\n</ul>\n<h1>category</h1>\n<p>分类</p>\n<ul>\n<li>新闻动态</li>\n<li>推荐精选</li>\n<li>概念理解</li>\n<li>实战技巧</li>\n<li>指导手册</li>\n<li>最佳实践</li>\n<li>疑难杂症</li>\n<li>心得体会</li>\n</ul>\n<h1>tags</h1>\n<p>标签，例如：</p>\n<ul>\n<li>HTML、CSS、JS、Python、...</li>\n<li>Nodejs、NPM、Nestjs、React、Ant Design、Gatsby、Knexjs、...</li>\n<li>git、github、...</li>\n<li>Linux、Docker、Kubernetes (K8S)、...</li>\n<li>PostgreSQL、RabbitMQ、Redis、...</li>\n</ul>\n<h1>keywords</h1>\n<p>关键字：</p>\n<h1>cover</h1>\n<p>封面图片链接</p>\n<h1>author</h1>\n<p>作者</p>\n<h1>created_when</h1>\n<p>创建日期</p>\n<h1>updated_when</h1>\n<p>更新日期</p>"},{"fields":{"filename":"20210125001_win_dev_env_setup"},"frontmatter":{"id":"20210125001_win_dev_env_setup","title":"Windows开发环境的安装设置","subtitle":"Windows系统下，基于Nodejs做全栈开发的系统设置","subject":"开发环境","author":"Chis Wei","keywords":"Windows;Development Environment","tags":"nodejs;fullstack","category":"指导手册","created_when":"2021-01-25","cover":"http://qiniuargus.weready.online/blog/Coder_desk.png"},"excerpt":"Windows开发环境的安装设置 Chrome Download Here 登录并同步信息 设置启动页 Firefox…","html":"<h1>Windows开发环境的安装设置</h1>\n<h2>Chrome</h2>\n<ol>\n<li><a href=\"https://www.google.com/chrome/\">Download Here</a></li>\n<li>登录并同步信息</li>\n<li>设置启动页</li>\n</ol>\n<h2>Firefox</h2>\n<ul>\n<li><a href=\"http://www.firefox.com.cn/\">Download Here</a></li>\n</ul>\n<h2>1Passport</h2>\n<ol>\n<li><a href=\"https://1password.com/\">Download Here</a></li>\n<li>同步信息</li>\n</ol>\n<h2>VPN</h2>\n<ol>\n<li>复制可执行文件</li>\n<li>配置服务器设置</li>\n</ol>\n<h2>Xshell</h2>\n<ol>\n<li><a href=\"https://www.netsarang.com/en/xshell/\">Download Here</a></li>\n<li>新建<code>会话</code>，连接到服务器</li>\n<li>添加到<code>会话地址栏</code></li>\n</ol>\n<h2>Git</h2>\n<ol>\n<li><a href=\"https://git-scm.com/downloads\">Download Here</a></li>\n<li><a href=\"https://git-scm.com/downloads/guis\">Check GUI clients here</a></li>\n</ol>\n<h2>Github Tools</h2>\n<ul>\n<li><a href=\"https://desktop.github.com/\">Github Desktop</a></li>\n</ul>\n<h2>SourceTree</h2>\n<ul>\n<li><a href=\"https://www.sourcetreeapp.com/\">Download Here</a></li>\n</ul>\n<h2>VSCode</h2>\n<ul>\n<li><a href=\"https://code.visualstudio.com/\">Download Here</a></li>\n<li>\n<p>安装扩展</p>\n<ul>\n<li>Chinese (Simplified) Language Pack for Visual Studio Code</li>\n<li>Markdown Preview Enhanced</li>\n<li>Quokka.js</li>\n<li>Emoji Snippets</li>\n<li>VSCode NestJs Snippets</li>\n<li>ES7 React/Redux/GraphQL/React-Native snippets</li>\n<li>vscode-styled-components</li>\n</ul>\n</li>\n</ul>\n<h2>Postman</h2>\n<ol>\n<li><a href=\"https://www.postman.com/downloads/\">Download Here</a></li>\n<li>登录账号</li>\n<li>同步数据</li>\n</ol>\n<h2>Nodejs</h2>\n<ol>\n<li><a href=\"https://nodejs.org/en/download/\">Download Here</a></li>\n<li>全局安装</li>\n</ol>\n<pre><code>npm install -g yarn\nnpm install -g mocha\nnpm install -g istanbul\n</code></pre>\n<h2>postgresql</h2>\n<ol>\n<li><a href=\"https://www.postgresql.org/download/\">Download Here</a></li>\n<li><a href=\"https://www.enterprisedb.com/downloads/postgres-postgresql-downloads\">Windows Version</a></li>\n</ol>\n<blockquote>\n<p>Stack Builder may fail. It doesn't matter.</p>\n</blockquote>\n<ol start=\"3\">\n<li>增加环境变量：C:\\Program Files\\PostgreSQL\\xx.x\\bin</li>\n<li>重启 Windows</li>\n<li>SQL Shell (psql)</li>\n</ol>\n<pre><code>c:\\xxx > psql\npostgres=# DROP DATABASE [database name];\npostgres=# DROP USER [user name];\npostgres=# CREATE USER [user name] WITH PASSWORD '[password]';\npostgres=# CREATE DATABASE [database name] OWNER [user name];\npostgres=# GRANT ALL PRIVILEGES ON DATABASE [database name] TO [user name];\n</code></pre>\n<ol start=\"6\">\n<li>安装扩展</li>\n</ol>\n<pre><code>c:\\xxx > psql -U [database name] -d [user name]\n[database name]=> \\c [database name] postgres;\n[database name]=# create extension ltree;\n[database name]=# create extension \"pgcrypto\";\n[database name]=# create extension tablefunc;\n[database name]=# \\c [database name] [user name];\n</code></pre>\n<h2>LENS</h2>\n<ul>\n<li><a href=\"https://github.com/lensapp/lens/releases/download/v3.5.0/Lens-Setup-3.5.0.exe\">Download Here</a></li>\n</ul>\n<h2>VMWare Workstation</h2>\n<ol>\n<li>Download</li>\n<li>Install</li>\n<li>创建虚机</li>\n<li>启动虚机</li>\n<li>安全容器或集群环境，参考：xxxx</li>\n</ol>\n<h2>其他</h2>\n<ul>\n<li>钉钉</li>\n<li>腾讯会议</li>\n</ul>"},{"fields":{"filename":"20210125004_pg_backup_restore"},"frontmatter":{"id":"20210125004_pg_backup_restore","title":"postgres 数据库的备份与恢复","subtitle":"pg数据库的全备份，以及数据恢复","subject":"运维","author":"Chis Wei","keywords":"数据备份;数据恢复","tags":"postgresql;devops","category":"指导手册","created_when":"2021-01-25","cover":"http://qiniuargus.weready.online/blog/coder.jpg"},"excerpt":"postgres 数据库的备份与恢复 参考 1 备份 命令格式 恢复 Option 1 进入容器 dbpg…","html":"<h1>postgres 数据库的备份与恢复</h1>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/0602d5c77b8f?tdsourcetag=s_pcqq_aiomsg\">1</a></li>\n</ul>\n<h2>备份</h2>\n<h4>命令格式</h4>\n<pre><code>pg_dump -h [host] -U [user] [database] > [output file]\n</code></pre>\n<pre><code>#!/bin/bash\n\npg_dump -h dbpg -U postgres [database] > /backup/pgdump.sql\nmv -f /backup/pgdump.sql /backup/pg_dump_`date +%Y%m%d%H%M%S`.sql\n</code></pre>\n<h2>恢复</h2>\n<h3>Option 1</h3>\n<h4>进入容器 <code>dbpg</code></h4>\n<h4>进入脚本目录</h4>\n<pre><code>cd script\n</code></pre>\n<h4>进入数据库</h4>\n<pre><code>psql -d archellis -U postgres\n</code></pre>\n<h4>清空数据</h4>\n<pre><code>\\i clear_all.sql;\n</code></pre>\n<h4>恢复数据</h4>\n<pre><code>\\i pg_dump_xxxxxxx.sql;\n</code></pre>\n<h3>Option 2</h3>\n<h4>登录数据库</h4>\n<pre><code>psql -U postgres \n</code></pre>\n<h4>断开所有连接</h4>\n<pre><code>SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname = 'archellis' AND pid &#x3C;> pg_backend_pid();\n</code></pre>\n<h4>退出登录</h4>\n<pre><code>\\q\n</code></pre>\n<h4>删除数据库</h4>\n<pre><code>dropdb -U postgres [database]\n</code></pre>\n<h4>创建数据库</h4>\n<pre><code>createdb -U postgres [database]\n</code></pre>\n<h4>恢复数据</h4>\n<pre><code>psql -d [database] -U postgres -f pg_dump_xxxxxxxx.sql\n</code></pre>"},{"fields":{"filename":"20210125003_k8s_cluster_setup"},"frontmatter":{"id":"20210125003_k8s_cluster_setup","title":"Kubernetes (k8s) 集群安装部署","subtitle":"在 CentOS 服务器环境下，K8S 一主一从的集群安装","subject":"云原生","author":"Chis Wei","keywords":"kubeadm;k8s集群","tags":"kubernetes;k8s;Ingress;calico;LENS","category":"指导手册","created_when":"2021-01-25","cover":"http://qiniuargus.weready.online/blog/tech_logos.png"},"excerpt":"Kubernetes (k8s) 集群安装部署 环境概述 阿里云 (athena) ECS (2C 8G) x…","html":"<h1>Kubernetes (k8s) 集群安装部署</h1>\n<h2>环境概述</h2>\n<ul>\n<li>阿里云 (athena) ECS (2C 8G) x2</li>\n<li>CentOS 7.8</li>\n<li>kubernetes 1.18</li>\n<li>[Master Public IP] ([Master Private IP]): k8s-m1 (master)</li>\n<li>[Worker Public IP] ([Worker Private IP]): k8s-w1 (worker)</li>\n</ul>\n<h2>准备工作</h2>\n<h4>检查操作系统版本</h4>\n<pre><code># cat /etc/redhat-release\nCentOS Linux release 7.8.2003 (Core)\n</code></pre>\n<h4>检查并修改机器名称</h4>\n<pre><code># hostname\n# hostnamectl\n# cat /etc/hostname\n</code></pre>\n<pre><code># vi /etc/hostname\n</code></pre>\n<pre><code>k8s-m1\n</code></pre>\n<pre><code># systemctl restart systemd-hostnamed\n</code></pre>\n<pre><code># reboot\n</code></pre>\n<h4>配置集群 hosts (私有地址)</h4>\n<pre><code># vi /etc/hosts\n</code></pre>\n<pre><code>[Master Private IP] k8s-m1\n[Worker Private IP] k8s-w1\n</code></pre>\n<h4>禁用<code>防火墙</code></h4>\n<pre><code># systemctl stop firewalld &#x26;&#x26; systemctl disable firewalld\n# systemctl stop firewalld\n</code></pre>\n<h4>禁用<code>selinux</code></h4>\n<pre><code># setenforce 0\n# sed -i '7s/enforcing/disabled/' /etc/selinux/config\n</code></pre>\n<pre><code># reboot\n</code></pre>\n<h4>创建配置文件（<code>/etc/sysctl.d/k8s.conf</code>）</h4>\n<blockquote>\n<p>创建文件并添加内容</p>\n</blockquote>\n<pre><code># cat >/etc/sysctl.d/k8s.conf &#x3C;&#x3C;EOF\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nEOF\n</code></pre>\n<blockquote>\n<p>执行命令使之生效</p>\n</blockquote>\n<pre><code># modprobe br_netfilter &#x26;&#x26; sysctl -p /etc/sysctl.d/k8s.conf\n</code></pre>\n<h4>安装ipvs</h4>\n<blockquote>\n<p>创建文件并添加内容（保证在节点重启后能自动加载所需模块）</p>\n</blockquote>\n<pre><code># cat > /etc/sysconfig/modules/ipvs.modules &#x3C;&#x3C;EOF\n#!/bin/bash\nmodprobe -- ip_vs\nmodprobe -- ip_vs_rr\nmodprobe -- ip_vs_wrr\nmodprobe -- ip_vs_sh\nmodprobe -- nf_conntrack_ipv4\nEOF\n</code></pre>\n<blockquote>\n<p>修改权限以及查看是否已经正确加载所需的内核模块</p>\n</blockquote>\n<pre><code># chmod 755 /etc/sysconfig/modules/ipvs.modules &#x26;&#x26; bash /etc/sysconfig/modules/ipvs.modules\n</code></pre>\n<blockquote>\n<p>查看是否已经正确加载所需的内核模块</p>\n</blockquote>\n<pre><code># lsmod | grep -e ip_vs -e nf_conntrack_ipv4\nnf_conntrack_ipv4      15053  0 \nnf_defrag_ipv4         12729  1 nf_conntrack_ipv4\nip_vs_sh               12688  0 \nip_vs_wrr              12697  0 \nip_vs_rr               12600  0 \nip_vs                 145497  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr\nnf_conntrack          139264  2 ip_vs,nf_conntrack_ipv4\nlibcrc32c              12644  2 ip_vs,nf_conntrack\n</code></pre>\n<blockquote>\n<p>安装 <code>ipset</code> 和 <code>ipvsadm</code> (便于查看 ipvs 的代理规则)</p>\n</blockquote>\n<pre><code># yum -y install ipset ipvsadm\n</code></pre>\n<h4>同步服务器时间</h4>\n<blockquote>\n<p>安装chrony</p>\n</blockquote>\n<pre><code># yum -y install chrony\n</code></pre>\n<blockquote>\n<p>修改同步服务器地址为阿里云</p>\n</blockquote>\n<pre><code># sed -i.bak '3,6d' /etc/chrony.conf &#x26;&#x26; sed -i '3cserver ntp1.aliyun.com iburst' /etc/chrony.conf\n</code></pre>\n<blockquote>\n<p>启动<code>chronyd</code>及加入开机自启</p>\n</blockquote>\n<pre><code># systemctl start chronyd &#x26;&#x26; systemctl enable chronyd\n</code></pre>\n<blockquote>\n<p>查看同步结果</p>\n</blockquote>\n<pre><code># chronyc sources\n</code></pre>\n<h4>关闭<code>swap</code>分区</h4>\n<blockquote>\n<p>手动关闭swap</p>\n</blockquote>\n<pre><code># swapoff -a\n</code></pre>\n<blockquote>\n<p>修改fstab文件，注释swap自动挂载 (!!!!!! 此处有些问题：貌似原文件中并没有这句话，因此这个命令实际并未发生作用 !!!!!!)</p>\n</blockquote>\n<pre><code># sed -i '/^\\/dev\\/mapper\\/centos-swap/c#/dev/mapper/centos-swap swap                    swap    defaults        0 0' /etc/fstab\n</code></pre>\n<blockquote>\n<p>查看swap是否关闭</p>\n</blockquote>\n<pre><code># free -m\n              total        used        free      shared  buff/cache   available\nMem:           7821         123        7395           0         301        7472\nSwap:             0           0           0\n</code></pre>\n<blockquote>\n<p><code>swappiness</code> 参数调整，修改<code>/etc/sysctl.d/k8s.conf</code>添加下面一行</p>\n</blockquote>\n<pre><code># cat >>/etc/sysctl.d/k8s.conf &#x3C;&#x3C;EOF\nvm.swappiness=0\nEOF\n</code></pre>\n<blockquote>\n<p>使配置生效</p>\n</blockquote>\n<pre><code># sysctl -p /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_forward = 1\nvm.swappiness = 0\n</code></pre>\n<h2>安装</h2>\n<h4>安装 Docker18.09.9</h4>\n<blockquote>\n<p>安装 <code>yum-utils</code> 命令包，从而可以使用 <code>yum-config-manager</code> 命令</p>\n</blockquote>\n<pre><code>yum -y install yum-utils\n</code></pre>\n<blockquote>\n<p>添加阿里云yum源</p>\n</blockquote>\n<pre><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n</code></pre>\n<blockquote>\n<p>查看可用版本</p>\n</blockquote>\n<pre><code>yum list docker-ce --showduplicates | sort -r\n已加载插件：fastestmirror, langpacks\n可安装的软件包\n * updates: mirrors.aliyun.com\nLoading mirror speeds from cached hostfile\n * extras: mirrors.aliyun.com\ndocker-ce.x86_64            3:19.03.5-3.el7                     docker-ce-stable\ndocker-ce.x86_64            3:19.03.4-3.el7                     docker-ce-stable\n。。。。。。\ndocker-ce.x86_64            3:18.09.9-3.el7                     docker-ce-stable\ndocker-ce.x86_64            3:18.09.8-3.el7                     docker-ce-stable\ndocker-ce.x86_64            3:18.09.7-3.el7                     docker-ce-stable\ndocker-ce.x86_64            3:18.09.6-3.el7                     docker-ce-stable\n。。。。。。\n</code></pre>\n<blockquote>\n<p>安装docker18.09.9</p>\n</blockquote>\n<pre><code>yum -y install docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9\n</code></pre>\n<blockquote>\n<p>启动docker并设置开机自启</p>\n</blockquote>\n<pre><code>systemctl enable docker &#x26;&#x26; systemctl start docker\n</code></pre>\n<blockquote>\n<p>配置阿里云docker镜像加速</p>\n</blockquote>\n<pre><code>cat > /etc/docker/daemon.json &#x3C;&#x3C;-'EOF'\n{\n  \"registry-mirrors\": [\"https://gqk8w9va.mirror.aliyuncs.com\"]\n}\nEOF\n</code></pre>\n<blockquote>\n<p>配置完后重启docker</p>\n</blockquote>\n<pre><code>systemctl restart docker\n</code></pre>\n<blockquote>\n<p>查看加速</p>\n</blockquote>\n<pre><code>docker info\n</code></pre>\n<p>找到Registry Mirrors一行\nRegistry Mirrors:\n<a href=\"https://gqk8w9va.mirror.aliyuncs.com/\">https://gqk8w9va.mirror.aliyuncs.com/</a></p>\n<blockquote>\n<p>查看docker版本</p>\n</blockquote>\n<pre><code>docker version\n\nClient:\n Version:           18.09.9\n API version:       1.39\n Go version:        go1.11.13\n Git commit:        039a7df9ba\n Built:             Wed Sep  4 16:51:21 2019\n OS/Arch:           linux/amd64\n Experimental:      false\n\nServer: Docker Engine - Community\n Engine:\n  Version:          18.09.9\n  API version:      1.39 (minimum version 1.12)\n  Go version:       go1.11.13\n  Git commit:       039a7df\n  Built:            Wed Sep  4 16:22:32 2019\n  OS/Arch:          linux/amd64\n  Experimental:     false\n</code></pre>\n<h4>修改<code>docker Cgroup Driver</code>为<code>systemd</code></h4>\n<blockquote>\n<p>将/usr/lib/systemd/system/docker.service文件中的这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\n修改为 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd\n如果不修改，在添加 worker 节点时可能会碰到如下错误\n[WARNING IsDockerSystemdCheck]: detected \"cgroupfs\" as the Docker cgroup driver. The recommended driver is \"systemd\".\nPlease follow the guide at <a href=\"https://kubernetes.io/docs/setup/cri/\">https://kubernetes.io/docs/setup/cri/</a></p>\n</blockquote>\n<blockquote>\n<p>使用如下命令修改</p>\n</blockquote>\n<pre><code>sed -i.bak \"s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g\" /usr/lib/systemd/system/docker.service\n</code></pre>\n<blockquote>\n<p>重启docker</p>\n</blockquote>\n<pre><code>systemctl daemon-reload &#x26;&#x26; systemctl restart docker\n</code></pre>\n<h4>安装<code>Kubeadm</code></h4>\n<blockquote>\n<p>使用阿里云<code>yum</code>源</p>\n</blockquote>\n<pre><code>cat >/etc/yum.repos.d/kubernetes.repo &#x3C;&#x3C;EOF\n[kubernetes]\nname=Kubernetes\nbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\n        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n</code></pre>\n<blockquote>\n<p>安装 <code>kubeadm</code>、<code>kubelet</code>、<code>kubectl</code> (阿里云yum源会随官方更新最新版，因此指定版本)</p>\n</blockquote>\n<blockquote>\n<p>安装1.18.4版本</p>\n</blockquote>\n<pre><code>yum -y install kubelet-1.18.4 kubeadm-1.18.4 kubectl-1.18.4\n</code></pre>\n<blockquote>\n<p>查看版本</p>\n</blockquote>\n<pre><code>kubeadm version\n\nkubeadm version: &#x26;version.Info{Major:\"1\", Minor:\"16\", GitVersion:\"v1.18.4\", GitCommit:\"a17149e1a189050796ced469dbd78d380f2ed5ef\", GitTreeState:\"clean\", BuildDate:\"2020-04-16T11:42:30Z\", GoVersion:\"go1.13.9\", Compiler:\"gc\", Platform:\"linux/amd64\"}\n</code></pre>\n<blockquote>\n<p>设置<code>kubelet</code>开机自启</p>\n</blockquote>\n<pre><code>systemctl enable kubelet\n</code></pre>\n<blockquote>\n<p>设置<code>k8s</code>命令自动补全</p>\n</blockquote>\n<pre><code>yum -y install bash-completion\nsource /usr/share/bash-completion/bash_completion\nsource &#x3C;(kubectl completion bash)\necho \"source &#x3C;(kubectl completion bash)\" >> ~/.bashrc\n</code></pre>\n<h1>初始化集群</h1>\n<h2>初始化 <code>master</code> 节点</h2>\n<h4>配置 <code>kubeadm</code> 初始化文件</h4>\n<pre><code>cat &#x3C;&#x3C;EOF > ./kubeadm-config.yaml\napiVersion: kubeadm.k8s.io/v1beta2\nkind: ClusterConfiguration\nkubernetesVersion: v1.18.3\nimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers\n\n#master地址\ncontrolPlaneEndpoint: \"[Mater Private IP]:6443\" \nnetworking:\n  serviceSubnet: \"10.96.0.0/16\" \n\n  #k8s容器组所在的网段\n  podSubnet: \"10.20.0.1/16\" \n  dnsDomain: \"cluster.local\"\n\n# 为了让证书包含公网IP，从而允许从外网访问集群\napiServer:\n  certSANs:       #填写所有kube-apiserver节点的hostname、IP、VIP\n  - k8s-m1        #请替换为hostname\n  - [Master Public IP]  #请替换为公网\n  - [Mater Private IP]  #请替换为私网\n  - 10.96.0.1     #不要替换，此IP是API的集群地址，部分服务会用到\n\nEOF\n</code></pre>\n<h4>初始化 <code>master</code></h4>\n<blockquote>\n<p>⚠️如果想要重新初始化，需要执行命令 <code>kubeadm reset -f</code></p>\n</blockquote>\n<blockquote>\n<p><code>kubeadm init --config=kubeadm-config.yaml --upload-certs</code></p>\n</blockquote>\n<pre><code># kubeadm init --config=kubeadm-config.yaml\n\n....\n\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME/.kube\n  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n  sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\nYou should now deploy a pod network to the cluster.\nRun \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:\n  https://kubernetes.io/docs/concepts/cluster-administration/addons/\n\nYou can now join any number of control-plane nodes by copying certificate authorities\nand service account keys on each node and then running the following as root:\n\n  kubeadm join [Mater Private IP]:6443 --token xxxxxx.xxxxxxxxxxxxxxxxx \\\n    --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \\\n    --control-plane \n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join [Mater Private IP]:6443 --token xxxxxx.xxxxxxxxxxxxxxxxx \\\n    --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n</code></pre>\n<blockquote>\n<p>⚠️ 保存 token sha256</p>\n</blockquote>\n<blockquote>\n<p>拷贝 <code>kubeconfig</code> 文件（这里的路径为 <code>/root</code>）</p>\n</blockquote>\n<pre><code>mkdir -p $HOME/.kube\ncp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nchown $(id -u):$(id -g) $HOME/.kube/config\n</code></pre>\n<h2>初始化 <code>worker</code> 节点</h2>\n<blockquote>\n<p>将master节点上的 <code>$HOME/.kube/config</code> 文件拷贝到 <code>worker</code> 节点对应的文件中</p>\n</blockquote>\n<pre><code>mkdir -p $HOME/.kube \nscp k8s-m1:~/.kube/config $HOME/.kube\nchown $(id -u):$(id -g) $HOME/.kube/config\n</code></pre>\n<blockquote>\n<p>将 <code>worker</code> 节点加入到集群中</p>\n</blockquote>\n<blockquote>\n<p>这里需要用到2.2中初始化master最后生成的token和sha256值</p>\n</blockquote>\n<pre><code>kubeadm join [Mater Private IP]:6443 --token xxxxxx.xxxxxxxxxxxxxxxxx \\\n    --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \n\n... ...\n\nThis node has joined the cluster:\n* Certificate signing request was sent to apiserver and a response was received.\n* The Kubelet was informed of the new secure connection details.\n\nRun 'kubectl get nodes' on the control-plane to see this node join the cluster.\n</code></pre>\n<blockquote>\n<p>如果忘记了token和sha256值，可以在master节点使用如下命令查看</p>\n</blockquote>\n<pre><code>#kubeadm token list\nTOKEN                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA GROUPS\npx979r.mphk9ee5ya8fgy44   20h       2020-03-18T13:49:48+08:00   authentication,signing   &#x3C;none>        system:bootstrappers:kubeadm:default-node-token\n</code></pre>\n<blockquote>\n<p>查看sha256</p>\n</blockquote>\n<pre><code>#openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<blockquote>\n<p>同时查看token和sha256</p>\n</blockquote>\n<pre><code>#kubeadm token create --print-join-command\nkubeadm join 192.168.9.10:6443 --token 9b28zg.oyt0kvvpmtrem4bg     --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n</code></pre>\n<blockquote>\n<p>master节点查看node（发现状态都是NotReady，因为还没有安装网络插件，这里我们安装calio官方插件文档）</p>\n</blockquote>\n<pre><code>kubectl get nodes\n</code></pre>\n<h2><code>Master</code> 节点安装网络插件calio</h2>\n<blockquote>\n<p>下载文件</p>\n</blockquote>\n<pre><code>wget https://docs.projectcalico.org/v3.8/manifests/calico.yaml\n</code></pre>\n<blockquote>\n<p>因为在上边kubeadm-config.yaml配置文件中指定了容器组IP，所以需要将文件中的<code>625</code>行改为如下：</p>\n</blockquote>\n<pre><code>value: \"10.20.0.1/16\"\n</code></pre>\n<blockquote>\n<p>vi 命令</p>\n</blockquote>\n<pre><code>:set number\n</code></pre>\n<blockquote>\n<p>修改完成后安装calico网络插件</p>\n</blockquote>\n<pre><code>kubectl apply -f calico.yaml\n</code></pre>\n<blockquote>\n<p>安装完成后稍等一会查看pods状态</p>\n</blockquote>\n<pre><code>kubectl get pods -n kube-system\n</code></pre>\n<blockquote>\n<p>查看node状态</p>\n</blockquote>\n<pre><code>kubectl get nodes \n</code></pre>\n<h2>启动 <code>LENS</code></h2>\n<h4>阿里云开通 <code>6443</code> 端口</h4>\n<h4>Lens 添加集群</h4>\n<pre><code>cat ~/.kube/config\n</code></pre>\n<blockquote>\n<p>IP 修改为公网IP</p>\n</blockquote>\n<h4>启用集群的 <code>Metrics</code> Feature</h4>\n<h1>准备镜像</h1>\n<h4>镜像列表</h4>\n<ul>\n<li>registry.cn-beijing.aliyuncs.com/[???]/worker:0.2.0-[???]</li>\n<li>registry.cn-beijing.aliyuncs.com/[???]/service:0.2.0-[???]</li>\n<li>registry.cn-beijing.aliyuncs.com/[???]/frontend:0.2.0-[???]</li>\n<li>rabbitmq:3.8.2-alpine</li>\n<li>postgres:12.1-alpine</li>\n<li>node:12.14.1-alpine</li>\n<li>redis:5.0.7-alpine</li>\n<li>nginx:1.17.6-alpine</li>\n<li>busybox</li>\n</ul>\n<h4>命令 - 登录阿里云镜像服务</h4>\n<pre><code>docker login -u [user name] -p [password] registry.cn-hangzhou.aliyuncs.com\n</code></pre>\n<blockquote>\n<p>可以参考阿里云镜像服务的命令行提示</p>\n</blockquote>\n<h4>命令 - 获取镜像</h4>\n<pre><code>docker pull\n</code></pre>\n<h1>安装 Git</h1>\n<pre><code>yum install git\n</code></pre>\n<h1>获取 Demo 脚本</h1>\n<blockquote>\n<p>git repo of dockerimages</p>\n</blockquote>\n<pre><code>#!/bin/bash\ngit clone --depth=1 https://[user name]:[password]@github.com/YunzhiWei/dockerimages.git\n</code></pre>\n<h1>启动 Ingress</h1>\n<h2>Ingress Controller of Traefik</h2>\n<blockquote>\n<p>切换到 <code>architecture/traefik</code> 目录</p>\n</blockquote>\n<h4>Apply rbac role and role binding</h4>\n<pre><code># kubectl apply -f traefik-rbac.yaml\n# kubectl describe clusterrole traefik-ingress-controller -n kube-system\n</code></pre>\n<h4>Apply daemonset</h4>\n<pre><code>kubectl apply -f traefik-ds-http.yaml\nkubectl get all -n kube-system | grep traefik\n</code></pre>"},{"fields":{"filename":"20210125002_docker_compose_setup"},"frontmatter":{"id":"20210125002_docker_compose_setup","title":"Docker Compose 的安装设置","subtitle":"CentOS 下 Docker 和 Docker Compose 的安装配置","subject":"开发环境","author":"Chis Wei","keywords":"Docker;淘宝镜像;基本命令","tags":"Docker Compose","category":"指导手册","created_when":"2021-01-25","cover":"http://qiniuargus.weready.online/blog/app_logos.png"},"excerpt":"Docker Compose 的安装设置 参考文章 Get Docker Engine - Community for…","html":"<h1>Docker Compose 的安装设置</h1>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">Get Docker Engine - Community for CentOS</a></li>\n<li><a href=\"https://www.cnblogs.com/morang/p/9501223.html\">docker 及 docker-compose 的快速安装和简单使用</a></li>\n</ul>\n<h2>Install Docker</h2>\n<ol>\n<li>SET UP THE REPOSITORY</li>\n</ol>\n<pre><code># sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n# sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n</code></pre>\n<ol start=\"2\">\n<li>INSTALL DOCKER ENGINE - COMMUNITY</li>\n</ol>\n<pre><code># sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n<ol start=\"3\">\n<li>Start Docker</li>\n</ol>\n<pre><code>$ sudo systemctl start docker\n</code></pre>\n<ol start=\"4\">\n<li>Verify that Docker Engine - Community is installed correctly by running the hello-world image.</li>\n</ol>\n<pre><code>$ sudo docker run hello-world\n</code></pre>\n<ol start=\"5\">\n<li>Verify that Docker Engine - Community is installed correctly by running the whalesay image. (Optional)</li>\n<li><a href=\"https://hub.docker.com/r/docker/whalesay\">docker/whalesa</a></li>\n</ol>\n<pre><code>$ docker run docker/whalesay cowsay boo\n</code></pre>\n<h2>使用中国区官方镜像</h2>\n<ol>\n<li>create json file</li>\n</ol>\n<pre><code># vi /etc/docker/daemon.json\n# cat /etc/docker/daemon.json\n</code></pre>\n<blockquote>\n<p>daemon.json</p>\n</blockquote>\n<pre><code>{\n  \"registry-mirrors\": [\"https://registry.docker-cn.com\"]\n}\n</code></pre>\n<ol start=\"2\">\n<li>restart docker</li>\n</ol>\n<pre><code># systemctl daemon-reload\n# systemctl restart docker\n# systemctl restart docker.service\n</code></pre>\n<ol start=\"3\">\n<li>reboot server</li>\n</ol>\n<pre><code># reboot\n</code></pre>\n<h2>Docker Compose</h2>\n<ol>\n<li>Download Docker Compose (with Daocloud Mirror)</li>\n</ol>\n<pre><code># curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n</code></pre>\n<ol>\n<li>Apply executable permissions to the binary:</li>\n</ol>\n<pre><code># chmod +x /usr/local/bin/docker-compose\n</code></pre>\n<ol>\n<li>Verify that Docker Compose</li>\n</ol>\n<pre><code># docker-compose --version\n</code></pre>\n<h2>基本命令</h2>\n<h3>run - Run a container</h3>\n<ul>\n<li>tag</li>\n</ul>\n<pre><code># docker run redis:4.0\n</code></pre>\n<ul>\n<li>STDIN</li>\n<li>-it (interactive mode, attach terminal)</li>\n<li>attach / detach (-d)</li>\n<li>Port Mapping (external:internal)</li>\n</ul>\n<pre><code># docker run -p 8001:3000 xxxxx\n# docker run -p 8002:3000 xxxxx\n# docker run -p 8003:3000 xxxxx\n# docker run -p 8004:3000 xxxxx\n</code></pre>\n<ul>\n<li>Volume Mapping</li>\n</ul>\n<pre><code># docker run --name db_pg_1 -v /my/own/datadir:/var/lib/postgresql/data -d postgres\n</code></pre>\n<ul>\n<li>Environment Variables</li>\n</ul>\n<pre><code># docker run -e APP_COLOR=blue XXXX\n</code></pre>\n<h3>ps - List containers</h3>\n<h3>stop - Stop a container</h3>\n<h3>rm - Remove a container</h3>\n<h3>rmi - Remove images</h3>\n<h3>pull - Download an image</h3>\n<h3>exec - Execute a command</h3>\n<h3>attach - attach a container</h3>\n<h3>inspect - inspect a container</h3>\n<h3>logs - show container's log</h3>\n<h3>示例</h3>\n<pre><code># docker run centos\n# docker run -it centos bash\n# docker ps\n# docker ps -a\n# docker run centos sleep 20\n# docker run -d --name thistest centos sleep 100\n# docker exec thistest cat /etc/*release*\n# docker stop thistest\n# docker rm xxx xxx xxx\n# docker images\n# docker rmi xxxx\n# docker pull centos\n# docker inspect thistest\n# docker logs thistest\n</code></pre>\n<h2>典型镜像</h2>\n<h3>使用 Node:alpine 启动 js 脚本</h3>\n<pre><code># docker run -it --rm --name node_main_1 -v \"$PWD\":/usr/src/app -w /usr/src/app node:11.10.1-alpine node index.js\n</code></pre>\n<h3>使用 postgres:alpine 管理数据库</h3>\n<ol>\n<li>下载镜像</li>\n</ol>\n<pre><code># docker pull postgres:alpine\n</code></pre>\n<ol>\n<li>启动容器</li>\n</ol>\n<pre><code># docker run --name dbpg -e POSTGRES_PASSWORD=123456 -p 5432:5432 -d postgres:alpine\n</code></pre>\n<ol>\n<li>进入容器</li>\n</ol>\n<pre><code># docker exec -it dbpg /bin/bash\n</code></pre>\n<ol>\n<li>启动 psql </li>\n</ol>\n<pre><code>psql -U postgres -d postgres\n</code></pre>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://kodekloud.com/courses/296044\">Docker for the Absolute Beginner - Hands On</a></li>\n<li><a href=\"https://docs.docker.com/\">Docker Documents</a></li>\n<li><a href=\"https://www.jianshu.com/p/9ab7b89637e7\">docker实现postgresql</a></li>\n<li><a href=\"https://www.cnblogs.com/whych/p/9595671.html\">Docker网络和容器的通信</a></li>\n<li><a href=\"https://blog.csdn.net/u013355826/article/details/84987233\">docker中容器之间通信方式</a></li>\n<li><a href=\"https://www.cnblogs.com/neptunemoon/p/6512121.html#toc_30\">使用docker-compose 大杀器来部署服务</a></li>\n</ul>\n<h2>集成环境</h2>\n<h3>下载 Node 镜像</h3>\n<pre><code># docker pull node:12.14.0-alpine\n</code></pre>\n<h3>安装 Nodejs</h3>\n<ol>\n<li>download and install npm binary pakage</li>\n</ol>\n<pre><code>[root@ ~]# wget https://nodejs.org/dist/v12.14.0/node-v12.14.0-linux-x64.tar.xz\n[root@ ~]# tar -xvf node-v12.14.0-linux-x64.tar.xz\n[root@ ~]# ln -s ~/node-v12.14.0-linux-x64/bin/node /usr/bin/node\n[root@ ~]# ln -s ~/node-v12.14.0-linux-x64/bin/npm /usr/bin/npm\n[root@ ~]# npm -v\n[root@ ~]# node -v\n</code></pre>\n<p>可以使用国内镜像</p>\n<pre><code>[root@ ~]# wget https://npm.taobao.org/mirrors/node/v12.14.0/node-v12.14.0-linux-x64.tar.gz\n</code></pre>\n<blockquote>\n<p>install wget in case it is not installed</p>\n</blockquote>\n<pre><code>[root@ ~]# yum -y install wget\n</code></pre>\n<ol start=\"2\">\n<li>edit profile</li>\n</ol>\n<pre><code>[root@ ~]# vim /etc/profile\n[root@ ~]# cat /etc/profile\n</code></pre>\n<blockquote>\n<p>profile file content</p>\n</blockquote>\n<pre><code>export NODE_PATH=\"/root/node-v12.14.0-linux-x64\"\nexport PATH=$NODE_PATH/bin:$PATH\n</code></pre>\n<ol start=\"3\">\n<li>restart the server from console</li>\n</ol>\n<pre><code>[root@ ~]# reboot\n</code></pre>\n<ol start=\"4\">\n<li>install global npm packages</li>\n</ol>\n<pre><code>[root@ ~]# npm install -g yarn\n</code></pre>\n<pre><code>[root@ ~]# npm install -g gulp\n[root@ ~]# npm install -g cross-env\n[root@ ~]# npm install -g rimraf\n</code></pre>\n<p>可以使用淘宝镜像</p>\n<pre><code>npm install xxxx -g --registry=http://registry.npm.taobao.org\n</code></pre>"},{"fields":{"filename":"20210125005_pg_crosstab"},"frontmatter":{"id":"20210125005_pg_crosstab","title":"postgres 数据库的数据透视表","subtitle":"利用 pg 数据库的 crosstab 扩展功能，实现类似数据透视表的数据分类查询统计","subject":"数据统计","author":"Chis Wei","keywords":"crosstab;pivot;行列转置","tags":"postgresql","category":"实战技巧","created_when":"2021-01-25","cover":null},"excerpt":"postgres…","html":"<h1>postgres数据库的数据透视表</h1>\n<h2>背景 &#x26; 需求</h2>\n<p>几乎所有系统的<code>数据表</code>，可能都会有一些<code>状态字段</code>，这些字段的取值是有限个<code>状态</code>。无论是运营的需求层面，还是程序运行的业务逻辑判断层面，往往需要对这些<code>数据表</code>中的记录，根据不同的状态进行汇总统计，获取不同状态下，所有记录的统计结果。</p>\n<p>例如，假设一个 <em>任务</em> <code>数据表</code>(<code>t_tasks</code>)：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">id</th>\n<th align=\"center\">project_code</th>\n<th align=\"center\">state</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1001</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1002</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1003</td>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">DONE</td>\n</tr>\n<tr>\n<td align=\"center\">1004</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">PENDING</td>\n</tr>\n<tr>\n<td align=\"center\">1005</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1006</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n</tr>\n<tr>\n<td align=\"center\">1007</td>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">DONE</td>\n</tr>\n<tr>\n<td align=\"center\">1008</td>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">PENDING</td>\n</tr>\n<tr>\n<td align=\"center\">1009</td>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">WORKING</td>\n</tr>\n</tbody>\n</table>\n<p>期望得到这样的统计结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">project_code</th>\n<th align=\"center\">pending</th>\n<th align=\"center\">working</th>\n<th align=\"center\">done</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\"></td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<h2>解决方案</h2>\n<pre><code>SELECT *\nFROM crosstab(\n  'SELECT project_code::text, state, count(id) FROM t_tasks GROUP BY grouping sets((project_code, state)) ORDER BY 1,2',\n  $$values('PENDING'::text),('WORKING'::text),('DONE'::text)$$\n)\nAS (project text, PENDING int, WORKING int, DONE int)\n</code></pre>\n<blockquote>\n<p><code>crosstab</code> 是 <code>postgres</code> 的扩展功能，使用之前，需要安装相关扩展</p>\n</blockquote>\n<h2>说明</h2>\n<ul>\n<li><code>$$</code> 相当于单引号（<code>crosstab</code> 的参数是一个 SQL 语句字符串，字符串是由单引号括起来的，因此，在单引号里面，不能再使用单引号，这时候，可以使用 <code>$$</code> 代替单引号）</li>\n<li><code>crosstab</code> 有两个<code>入参</code>：<code>数据集</code>，<code>状态集</code></li>\n<li><code>数据集</code>有三列：<code>行标识</code>, <code>状态</code>, <code>取值</code></li>\n<li><code>状态集</code>：所有状态的列表</li>\n</ul>\n<h4>中间结果</h4>\n<p><code>SELECT project_code::text, state, count(id) FROM t_tasks GROUP BY grouping sets((project_code, state)) ORDER BY 1,2</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">project_code</th>\n<th align=\"center\">state</th>\n<th align=\"center\">count</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_1</td>\n<td align=\"center\">DONE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">PENDING</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_2</td>\n<td align=\"center\">DONE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">PENDING</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">PRJ_3</td>\n<td align=\"center\">WORKING</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody>\n</table>\n<h2>关键点</h2>\n<ul>\n<li>构造一个 SQL 语句，能够取得中间结果；这个 SQL 语句，就是 <code>crosstab</code> 的第一个参数：<code>数据集</code></li>\n<li>指明一个<code>状态集</code>，作为 <code>crosstab</code> 的第二个参数</li>\n</ul>\n<h2>补充</h2>\n<h3>状态集 的构造方式</h3>\n<h4>固定的<code>状态集</code></h4>\n<pre><code>$$values('PENDING'::text),('WORKING'::text),('DONE'::text)$$\n</code></pre>\n<h4>动态的<code>状态集</code>，动态构造</h4>\n<pre><code>const stateArray = ['PENDING', 'WORKING', 'DONE']\nconst cstr = ....\nconst sql = `\n  SELECT \n    distinct qa.serial_code AS id,\n    fb.form_serial_code, fb.form_title, form_index, fb.form_id, \n    fb.notice_template_id, fb.notice_template_code,\n    fb.notice_serial_code, fb.notice_title, fb.notice_id, \n    fb.employer_path, fb.employer_id, \n    fb.source_path, fb.source_id, \n    fb.created_by,\n    fb.created_when,\n    fb.updated_by,\n    fb.updated_when,\n    qa.* \n  FROM crosstab(\n    'SELECT serial_code, question_key, answer_value FROM dbt_biz_logs WHERE ${cstr} ORDER BY 1, 2',\n    'SELECT * FROM unnest(array[${stateArray}]) as exp'\n  )\n  AS qa(serial_code text, ${qtuple})\n  LEFT JOIN dbt_biz_logs fb ON fb.serial_code=qa.serial_code AND fb.category='FORM_FEEDBACK_QA'\n`\n</code></pre>\n<h4>来自数据库的枚举类型</h4>\n<pre><code>'SELECT e.enumlabel FROM pg_type t, pg_enum e WHERE t.oid=e.enumtypid AND t.typname=''dbe_workflow_task_result'' ORDER BY 1'\n</code></pre>"},{"fields":{"filename":"20210125006_wechat_dev_setup"},"frontmatter":{"id":"20210125006_wechat_dev_setup","title":"微信公众号开发的相关配置","subtitle":"基于微信公众号开发所需的公共号管理控制台相关配置","subject":"WeReady","author":"Chis Wei","keywords":"微信;公众号","tags":null,"category":"指导手册","created_when":"2021-01-25","cover":"http://qiniuargus.weready.online/blog/desktop.jpg"},"excerpt":"微信公众号开发的相关配置 参考文章  OAuth2.0实战之微信授权篇_慕课手记 wechat-api…","html":"<h1>微信公众号开发的相关配置</h1>\n<h2>参考文章</h2>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/555fec114eb040084cfe5d15\"></a></li>\n<li><a href=\"https://www.imooc.com/article/17696\">OAuth2.0实战之微信授权篇_慕课手记</a></li>\n<li><a href=\"http://doxmate.cool/node-webot/wechat-api/index.html#index_%E4%BA%A4%E6%B5%81%E7%BE%A4\">wechat-api Documentation</a></li>\n</ul>\n<h2>微信公众平台设置</h2>\n<p><a href=\"https://mp.weixin.qq.com\">微信公众平台</a></p>\n<h3>设置 ==> 公众号设置</h3>\n<h4>功能设置</h4>\n<ul>\n<li>设置JS接口安全域名</li>\n</ul>\n<p>[domainurl]</p>\n<ul>\n<li>设置网页授权域名</li>\n</ul>\n<p>[domainurl]</p>\n<ul>\n<li>下载 MP<em>verify</em>xxxxxxx.txt</li>\n</ul>\n<blockquote>\n<p>下载到 <code>/[project folder]/public</code>\n确保微信相关设置和代码的 setting/config 设置一致</p>\n</blockquote>\n<ul>\n<li>设置服务器路由</li>\n</ul>\n<pre><code>app.use(express.static(path.join(__dirname, 'public')));\n</code></pre>\n<h3>开发 ==> 基本配置</h3>\n<ul>\n<li>开发者ID（AppID）</li>\n<li>开发者密码（AppSecret）</li>\n<li>IP 白名单</li>\n<li>服务器地址（URL）</li>\n<li>令牌（Token）</li>\n<li>消息加解密方式</li>\n</ul>\n<blockquote>\n<p>确保项目的 setting 目录中的 appid、appsecret、url、token 的配置正确（真正部署到生产环境时，这些信息需要删除，并保存到服务器的环境变量中）\n确保服务器的 IP 地址在白名单之内：58.37.109.51\n消息加解密方式根据不同情况正确选择\n服务器地址（URL）需要能够正确解析并响应微信服务器的验证请求\n服务器地址（URL）举例：<code>http://www.[domainname].com/wechat/token/check</code>\n每次修改服务器配置，如果一切配置无误，则修改成功，配置生效，否则，无法完成修改（这也能够在一定程度上验证，微信服务器和代码的匹配）</p>\n</blockquote>\n<h3>开发 ==> 接口权限</h3>\n<ul>\n<li>未获得的接口</li>\n</ul>\n<blockquote>\n<p>微信小店\n设备功能</p>\n</blockquote>\n<ul>\n<li>网页授权</li>\n</ul>\n<blockquote>\n<p>与 <strong>设置 ==> 公众号设置</strong> 是同一个配置页面</p>\n</blockquote>\n<h4>微信支付 | 商户平台</h4>\n<p><a href=\"https://pay.weixin.qq.com\">微信支付商户平台</a></p>\n<h4>账户中心</h4>\n<ul>\n<li>操作证书：在本机安装操作证书</li>\n<li>商户信息：微信支付商户号（mchId）</li>\n<li>API 安全：API 密钥，设置 API 密钥（partnerKey）</li>\n</ul>\n<h4>产品中心</h4>\n<ul>\n<li>开发配置 -> 支付配置：公众号支付（authcheck）；扫码支付（notifyUrl）；</li>\n<li>APPID 授权管理：绑定授权（appId）</li>\n</ul>\n<h2>微信 Web 开发者工具</h2>\n<blockquote>\n<p>直接输入 URL，检查浏览器调试信息输出</p>\n</blockquote>\n<h2>开发环境 与 生产环境</h2>\n<p>切换 开发环境 与 生产环境 的时候，经常需要修改的微信配置包括：</p>\n<p>公众号：</p>\n<ul>\n<li>设置 ==> 公众号设置 ==> 功能设置 ==> 网页授权域名</li>\n<li>开发 ==> 基本配置 ==> 服务器配置 ==> 服务器地址（URL）</li>\n</ul>\n<p>商铺：</p>\n<ul>\n<li>产品中心 ==> 开发配置 ==> 支付配置 ==> 扫码回调链接</li>\n</ul>"},{"fields":{"filename":"20210128001_css_responsible_rem"},"frontmatter":{"id":"20210128001_css_responsible_rem","title":"font-size，em，rem在响应式布局中的应用","subtitle":"响应式布局，不再以所谓“像素的精准”为追求目标，而是追求页面能够自适应不同屏幕的尺寸","subject":"响应式布局","author":"Chis Wei","keywords":"rem;em;px","tags":"css","category":"实战技巧","created_when":"2021-01-28","cover":null},"excerpt":"font-size，em，rem在响应式布局中的应用 px，em，rem 概要 px 代表像素尺寸； em…","html":"<h1>font-size，em，rem在响应式布局中的应用</h1>\n<h2><code>px</code>，<code>em</code>，<code>rem</code> 概要</h2>\n<ul>\n<li><code>px</code> 代表像素尺寸；</li>\n<li><code>em</code> 表示当前DOM元素 <code>font size</code>，或者父级（向上追溯）DOM元素的 <code>font size</code>;</li>\n<li><code>rem</code> 表示根（<code>html</code>）元素 <code>font size</code>;</li>\n</ul>\n<h2>背景</h2>\n<p>为了实现响应式布局，页面针对不同的屏幕尺寸，需要动态调整大小。而页面上，最丰富的元素，就是<code>文字</code>。如何方便高效的设置并动态调整<code>文字</code>大小，就成了动态布局中，一个课题。</p>\n<h2>经验技巧</h2>\n<ul>\n<li>根（<code>html</code>）元素中明确设定 <code>font size</code>，缺省设置为：<code>16px</code>；浏览器尺寸变化时，尽量不动态调整；从而保持全局的统一；</li>\n<li>页面局部范围，如果有需要，明确的设定<code>font size</code>；当浏览器尺寸变化时，动态调整；</li>\n<li>所有跨页面复用的组件尺寸，采用 <code>rem</code> 为尺寸单位，并暴露 <code>size</code> 属性，并根据该属性动态调整组件大小；这样，所有组件，在不同页面，会有一个统一的效果；</li>\n<li>所有局部相关的展示，采用 <code>em</code> 为尺寸单位；这样，不同的局部，同样的样式标签，也会呈现不同的尺寸，满足不同局部的需要；</li>\n</ul>"},{"fields":{"filename":"20210125008_screen_usage"},"frontmatter":{"id":"20210125008_screen_usage","title":"XShell连接Linux服务器执行程序的常驻运行","subtitle":"XShell 下利用 screen 命令，实现命令行的后台常驻运行","subject":"运维","author":"Chis Wei","keywords":"screen;常驻运行","tags":"XShell","category":"实战技巧","created_when":"2021-01-25","cover":null},"excerpt":"Linux程序的常驻运行 安装 使用 创建一个新的会话 下面命令中test…","html":"<h1>Linux程序的常驻运行</h1>\n<h2>安装</h2>\n<pre><code>[root@VM_183_120_centos ~]# yum install screen -y \n[root@VM_183_120_centos ~]# rpm -qa|grep screen\n</code></pre>\n<h2>使用</h2>\n<h4>创建一个新的会话</h4>\n<p>下面命令中test为新建会话的名称</p>\n<pre><code>[root@VM_183_120_centos ~]# screen -S test\n</code></pre>\n<h4>查看已有会话</h4>\n<pre><code>[root@VM_183_120_centos ~]# screen -ls\n</code></pre>\n<h4>重连会话（在这里我们重连test）</h4>\n<pre><code>[root@VM_183_120_centos ~]# screen  -r test //可以是名字test也可以是session ID\n</code></pre>\n<h4>退出会话</h4>\n<pre><code>[root@VM_183_120_centos ~]#screen -d  &#x3C;session ID 或者 名字>\n</code></pre>\n<h4>清除dead 会话</h4>\n<p>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话</p>\n<pre><code>[root@VM_183_120_centos ~]#screen -wipe\n</code></pre>\n<h4>关闭或杀死窗口</h4>\n<ul>\n<li>方法 - 1</li>\n</ul>\n<p>退出会话后，使用 screen -X -S [session id] quit 命令，可以结束某个session</p>\n<pre><code>[root@1core2g201802 ~]# screen -ls\nThere are screens on:\n    14954.test  (Detached)\n    27902.frps  (Detached)\n2 Sockets in /var/run/screen/S-root.\n\n[root@1core2g201802 ~]# screen -X -S 14954 quit\n[root@1core2g201802 ~]# screen -ls\nThere is a screen on:\n    27902.frps  (Detached)\n1 Socket in /var/run/screen/S-root.\n</code></pre>\n<ul>\n<li>方法 - 2</li>\n</ul>\n<p>如果已经在某个 screen session 中，可以使用 exit 命令退出当前 session\n如下：在 test session 中执行 exit 命令</p>\n<pre><code>[root@1core2g201802 ~]# screen -ls\nThere are screens on:\n        15419.test      (Attached)\n        27902.frps      (Detached)\n2 Sockets in /var/run/screen/S-root.\n\n[root@1core2g201802 ~]# exit\n</code></pre>\n<blockquote>\n<p>注意</p>\n<p>Crtl + a +d     保存进程并退出作业(程序在screen中继续运行，screen -ls 可查看)</p>\n<p>exit            退出作业和进程(程序终止，screen -ls 不可查看)</p>\n</blockquote>"},{"fields":{"filename":"20210125007_lrzsz_usage"},"frontmatter":{"id":"20210125007_lrzsz_usage","title":"Windows 客户端和 Linux 服务器间的文件传输","subtitle":"利用 lrzsz 实现 XShell 下面，对 Linux 服务器的文件进行上传和下载","subject":"运维","author":"Chis Wei","keywords":"lrzsz;rz;sz;文件上传;文件下载","tags":"XShell","category":"实战技巧","created_when":"2021-01-25","cover":null},"excerpt":"Windows 客户端和 Linux 服务器间的文件传输 运行环境 XShell…","html":"<h1>Windows 客户端和 Linux 服务器间的文件传输</h1>\n<h4>运行环境</h4>\n<p><code>XShell</code></p>\n<h4>安装</h4>\n<pre><code>[root@.... ~]# yum install  lrzsz -y\n</code></pre>\n<h4>检查安装结果</h4>\n<pre><code>[root@.... ~]# rpm -qa |grep lrzsz\n</code></pre>\n<h4>上传文件（上传到 Linux 服务器）</h4>\n<pre><code>[root@.... ~]# rz\n</code></pre>\n<h4>下载文件（下载到 Windows 客户端）</h4>\n<pre><code>[root@.... ~]# sz [filename]\n</code></pre>"},{"fields":{"filename":"20210128002_css_div_ratio"},"frontmatter":{"id":"20210128002_css_div_ratio","title":"利用padding设置DOM元素的宽高比","subtitle":"在某些场合，需要将DOM元素设置为固定的宽高比，但是又不是固定的尺寸","subject":"响应式布局","author":"Chis Wei","keywords":"padding;z-index;position","tags":"css","category":"实战技巧","created_when":"2021-01-28","cover":null},"excerpt":"利用padding设置DOM元素的宽高比 padding, z-index, position…","html":"<h1>利用padding设置DOM元素的宽高比</h1>\n<h2><code>padding</code>, <code>z-index</code>, <code>position</code> 概要</h2>\n<ul>\n<li>元素的 <code>padding</code> 属性，如果取值是 <code>%</code> 的话，<code>%</code>的 基准是父元素的宽度</li>\n<li>元素的 <code>z-index</code> 属性可以决定元素在 <code>z</code> 轴上的显示位置</li>\n<li>元素的 <code>z-index</code> 属性如果要发挥作用，必须具有有效的 <code>position</code>属性</li>\n</ul>\n<h2>经验技巧</h2>\n<ul>\n<li><code>DummyRatioFrame</code> 组件元素是 <code>Container</code> 组件元素的子组件</li>\n<li><code>DummyRatioFrame</code> 的实际高度为 <code>0</code>，而 <code>padding-top</code> 是父元素宽度的 <code>xx%</code>，那么 <code>DummyRatioFrame</code> 就被撑起来，具有一个固定的宽高比</li>\n<li>作为 父组件的 <code>Container</code>，也就具备了固定的宽高比</li>\n<li><code>Container</code> 的其他子组件，可以设置 <code>position</code> 以及 其他定位属性，来取得 <code>Container</code> 的位置，决定自己的位置</li>\n</ul>"}]}}}